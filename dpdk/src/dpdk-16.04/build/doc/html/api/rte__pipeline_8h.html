<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DPDK: lib/librte_pipeline/rte_pipeline.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">16.04.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_9cc23110c523433deab11cddab39a876.html">librte_pipeline</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_pipeline.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__port_8h_source.html">rte_port.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__table_8h_source.html">rte_table.h</a>&gt;</code><br/>
</div>
<p><a href="rte__pipeline_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pipeline__params.html">rte_pipeline_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pipeline__port__in__stats.html">rte_pipeline_port_in_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pipeline__port__out__stats.html">rte_pipeline_port_out_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pipeline__table__stats.html">rte_pipeline_table_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pipeline__table__params.html">rte_pipeline_table_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pipeline__port__in__params.html">rte_pipeline_port_in_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pipeline__port__out__params.html">rte_pipeline_port_out_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae53c3736fb2a1edc8e4b9b185d9d8fc3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#ae53c3736fb2a1edc8e4b9b185d9d8fc3">RTE_PIPELINE_TABLE_MAX</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:ae53c3736fb2a1edc8e4b9b185d9d8fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107216ecaebb628afdf1f3861cb8d9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#aa107216ecaebb628afdf1f3861cb8d9c">RTE_PIPELINE_PORT_IN_MAX</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:aa107216ecaebb628afdf1f3861cb8d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ae017901472b93f0d727f7663d788a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#af8ae017901472b93f0d727f7663d788a">RTE_PIPELINE_PORT_OUT_MAX</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:af8ae017901472b93f0d727f7663d788a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a690cec4a2e911968eb8036b333396f7f"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a690cec4a2e911968eb8036b333396f7f">rte_pipeline_table_action_handler_hit</a> )(struct rte_pipeline *p, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint64_t pkts_mask, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **entries, void *arg)</td></tr>
<tr class="separator:a690cec4a2e911968eb8036b333396f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985a626a1682c9b73f280d3af5b0c161"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a985a626a1682c9b73f280d3af5b0c161">rte_pipeline_table_action_handler_miss</a> )(struct rte_pipeline *p, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint64_t pkts_mask, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *entry, void *arg)</td></tr>
<tr class="separator:a985a626a1682c9b73f280d3af5b0c161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e46798593a5225761fda51abd2e0e0"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a07e46798593a5225761fda51abd2e0e0">rte_pipeline_port_in_action_handler</a> )(struct rte_pipeline *p, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint32_t n, void *arg)</td></tr>
<tr class="separator:a07e46798593a5225761fda51abd2e0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1be123ee7fbf0f0e8aacd79bc9b10d"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a6c1be123ee7fbf0f0e8aacd79bc9b10d">rte_pipeline_port_out_action_handler</a> )(struct rte_pipeline *p, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint64_t pkts_mask, void *arg)</td></tr>
<tr class="separator:a6c1be123ee7fbf0f0e8aacd79bc9b10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6376b240935404d998f003d113651572"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a6376b240935404d998f003d113651572">rte_pipeline_action</a> { <br/>
&#160;&#160;<a class="el" href="rte__pipeline_8h.html#a6376b240935404d998f003d113651572af41296546f2a86d1f8f1848010c7c111">RTE_PIPELINE_ACTION_DROP</a> = 0, 
<a class="el" href="rte__pipeline_8h.html#a6376b240935404d998f003d113651572ac8c58609785d844989b7d9eb1e6db8aa">RTE_PIPELINE_ACTION_PORT</a>, 
<a class="el" href="rte__pipeline_8h.html#a6376b240935404d998f003d113651572a5dc23d641b483615ea475152ac7ab7f4">RTE_PIPELINE_ACTION_PORT_META</a>, 
<a class="el" href="rte__pipeline_8h.html#a6376b240935404d998f003d113651572abafaf6276afcfcb170a2f7aa44c21048">RTE_PIPELINE_ACTION_TABLE</a>, 
<br/>
&#160;&#160;<a class="el" href="rte__pipeline_8h.html#a6376b240935404d998f003d113651572a34f0fbbbdce5f615d27dc0105b1640c3">RTE_PIPELINE_ACTIONS</a>
<br/>
 }</td></tr>
<tr class="separator:a6376b240935404d998f003d113651572"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad650149ed178057bfb54bda0b6e39e05"><td class="memItemLeft" align="right" valign="top">struct rte_pipeline *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#ad650149ed178057bfb54bda0b6e39e05">rte_pipeline_create</a> (struct <a class="el" href="structrte__pipeline__params.html">rte_pipeline_params</a> *params)</td></tr>
<tr class="separator:ad650149ed178057bfb54bda0b6e39e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ce2e4661092748a84409a1d6eae14c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a85ce2e4661092748a84409a1d6eae14c">rte_pipeline_free</a> (struct rte_pipeline *p)</td></tr>
<tr class="separator:a85ce2e4661092748a84409a1d6eae14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada72ecd95a1a181d1d555dd699f95475"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#ada72ecd95a1a181d1d555dd699f95475">rte_pipeline_check</a> (struct rte_pipeline *p)</td></tr>
<tr class="separator:ada72ecd95a1a181d1d555dd699f95475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4570eddec506f947c5c91cb2334a2eda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a4570eddec506f947c5c91cb2334a2eda">rte_pipeline_run</a> (struct rte_pipeline *p)</td></tr>
<tr class="separator:a4570eddec506f947c5c91cb2334a2eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26447a6b0c4b1ec218a9133d790fef1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#ac26447a6b0c4b1ec218a9133d790fef1">rte_pipeline_flush</a> (struct rte_pipeline *p)</td></tr>
<tr class="separator:ac26447a6b0c4b1ec218a9133d790fef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cb4d7ac4516443e6f9d82a4beebed6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#af1cb4d7ac4516443e6f9d82a4beebed6">rte_pipeline_table_create</a> (struct rte_pipeline *p, struct <a class="el" href="structrte__pipeline__table__params.html">rte_pipeline_table_params</a> *params, uint32_t *table_id)</td></tr>
<tr class="separator:af1cb4d7ac4516443e6f9d82a4beebed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8980fbc2a51d6dc8041b798ea5172318"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a8980fbc2a51d6dc8041b798ea5172318">rte_pipeline_table_default_entry_add</a> (struct rte_pipeline *p, uint32_t table_id, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *default_entry, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **default_entry_ptr)</td></tr>
<tr class="separator:a8980fbc2a51d6dc8041b798ea5172318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83e9cacb91301a7425694f32249e050"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#ac83e9cacb91301a7425694f32249e050">rte_pipeline_table_default_entry_delete</a> (struct rte_pipeline *p, uint32_t table_id, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *entry)</td></tr>
<tr class="separator:ac83e9cacb91301a7425694f32249e050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e90e4a54b6467deb9b449bf8bd5cab4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a0e90e4a54b6467deb9b449bf8bd5cab4">rte_pipeline_table_entry_add</a> (struct rte_pipeline *p, uint32_t table_id, void *key, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *entry, int *key_found, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **entry_ptr)</td></tr>
<tr class="separator:a0e90e4a54b6467deb9b449bf8bd5cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f0d5610d152c1e6f641928c4f0743"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a946f0d5610d152c1e6f641928c4f0743">rte_pipeline_table_entry_delete</a> (struct rte_pipeline *p, uint32_t table_id, void *key, int *key_found, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *entry)</td></tr>
<tr class="separator:a946f0d5610d152c1e6f641928c4f0743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cffe0cc5ee976c84d57af72b570523"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a95cffe0cc5ee976c84d57af72b570523">rte_pipeline_table_entry_add_bulk</a> (struct rte_pipeline *p, uint32_t table_id, void **keys, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **entries, uint32_t n_keys, int *key_found, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **entries_ptr)</td></tr>
<tr class="separator:a95cffe0cc5ee976c84d57af72b570523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c2e2a595e117cd9ae797fee6ab253a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a20c2e2a595e117cd9ae797fee6ab253a">rte_pipeline_table_entry_delete_bulk</a> (struct rte_pipeline *p, uint32_t table_id, void **keys, uint32_t n_keys, int *key_found, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **entries)</td></tr>
<tr class="separator:a20c2e2a595e117cd9ae797fee6ab253a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb68f21e8a212dcf698077b66e53e94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a3fb68f21e8a212dcf698077b66e53e94">rte_pipeline_table_stats_read</a> (struct rte_pipeline *p, uint32_t table_id, struct <a class="el" href="structrte__pipeline__table__stats.html">rte_pipeline_table_stats</a> *stats, int clear)</td></tr>
<tr class="separator:a3fb68f21e8a212dcf698077b66e53e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c0f093519ccc9fbb76e7c5696fd266"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#ab0c0f093519ccc9fbb76e7c5696fd266">rte_pipeline_port_in_create</a> (struct rte_pipeline *p, struct <a class="el" href="structrte__pipeline__port__in__params.html">rte_pipeline_port_in_params</a> *params, uint32_t *port_id)</td></tr>
<tr class="separator:ab0c0f093519ccc9fbb76e7c5696fd266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4634b81c75f146f3afac17dbbe727c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#adc4634b81c75f146f3afac17dbbe727c">rte_pipeline_port_in_connect_to_table</a> (struct rte_pipeline *p, uint32_t port_id, uint32_t table_id)</td></tr>
<tr class="separator:adc4634b81c75f146f3afac17dbbe727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a48f99a99731883005dfe93c5406e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#af8a48f99a99731883005dfe93c5406e6">rte_pipeline_port_in_enable</a> (struct rte_pipeline *p, uint32_t port_id)</td></tr>
<tr class="separator:af8a48f99a99731883005dfe93c5406e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3750798dfd9a03093790d52dd94aca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a6b3750798dfd9a03093790d52dd94aca">rte_pipeline_port_in_disable</a> (struct rte_pipeline *p, uint32_t port_id)</td></tr>
<tr class="separator:a6b3750798dfd9a03093790d52dd94aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790da0e2e134063df3eaa55bf6b70342"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a790da0e2e134063df3eaa55bf6b70342">rte_pipeline_port_in_stats_read</a> (struct rte_pipeline *p, uint32_t port_id, struct <a class="el" href="structrte__pipeline__port__in__stats.html">rte_pipeline_port_in_stats</a> *stats, int clear)</td></tr>
<tr class="separator:a790da0e2e134063df3eaa55bf6b70342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247f58fe13cba38922ccf5c60a2f86bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a247f58fe13cba38922ccf5c60a2f86bb">rte_pipeline_port_out_create</a> (struct rte_pipeline *p, struct <a class="el" href="structrte__pipeline__port__out__params.html">rte_pipeline_port_out_params</a> *params, uint32_t *port_id)</td></tr>
<tr class="separator:a247f58fe13cba38922ccf5c60a2f86bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab831fab1384d2dc680140e08bd2acdff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#ab831fab1384d2dc680140e08bd2acdff">rte_pipeline_port_out_stats_read</a> (struct rte_pipeline *p, uint32_t port_id, struct <a class="el" href="structrte__pipeline__port__out__stats.html">rte_pipeline_port_out_stats</a> *stats, int clear)</td></tr>
<tr class="separator:ab831fab1384d2dc680140e08bd2acdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abe46f84e0842eec2f0f52083706fc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a2abe46f84e0842eec2f0f52083706fc4">rte_pipeline_port_out_packet_insert</a> (struct rte_pipeline *p, uint32_t port_id, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *pkt)</td></tr>
<tr class="separator:a2abe46f84e0842eec2f0f52083706fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff1ad7418708c021c3fbfc672c72355"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#adff1ad7418708c021c3fbfc672c72355">rte_pipeline_ah_packet_hijack</a> (struct rte_pipeline *p, uint64_t pkts_mask)</td></tr>
<tr class="separator:adff1ad7418708c021c3fbfc672c72355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2508aa80b0fe3e7cc6b163e783d32342"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__pipeline_8h.html#a2508aa80b0fe3e7cc6b163e783d32342">rte_pipeline_ah_packet_drop</a> (struct rte_pipeline *p, uint64_t pkts_mask)</td></tr>
<tr class="separator:a2508aa80b0fe3e7cc6b163e783d32342"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Pipeline</p>
<p>This tool is part of the DPDK Packet Framework tool suite and provides a standard methodology (logically similar to OpenFlow) for rapid development of complex packet processing pipelines out of ports, tables and actions.</p>
<p><b>Basic operation.</b> A pipeline is constructed by connecting its input ports to its output ports through a chain of lookup tables. As result of lookup operation into the current table, one of the table entries (or the default table entry, in case of lookup miss) is identified to provide the actions to be executed on the current packet and the associated action meta-data. The behavior of user actions is defined through the configurable table action handler, while the reserved actions define the next hop for the current packet (either another table, an output port or packet drop) and are handled transparently by the framework.</p>
<p><b>Initialization and run-time flows.</b> Once all the pipeline elements (input ports, tables, output ports) have been created, input ports connected to tables, table action handlers configured, tables populated with the initial set of entries (actions and action meta-data) and input ports enabled, the pipeline runs automatically, pushing packets from input ports to tables and output ports. At each table, the identified user actions are being executed, resulting in action meta-data (stored in the table entry) and packet meta-data (stored with the packet descriptor) being updated. The pipeline tables can have further updates and input ports can be disabled or enabled later on as required.</p>
<p><b>Multi-core scaling.</b> Typically, each CPU core will run its own pipeline instance. Complex application-level pipelines can be implemented by interconnecting multiple CPU core-level pipelines in tree-like topologies, as the same port devices (e.g. SW rings) can serve as output ports for the pipeline running on CPU core A, as well as input ports for the pipeline running on CPU core B. This approach enables the application development using the pipeline (CPU cores connected serially), cluster/run-to-completion (CPU cores connected in parallel) or mixed (pipeline of CPU core clusters) programming models.</p>
<p><b>Thread safety.</b> It is possible to have multiple pipelines running on the same CPU core, but it is not allowed (for thread safety reasons) to have multiple CPU cores running the same pipeline instance. </p>

<p>Definition in file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ae53c3736fb2a1edc8e4b9b185d9d8fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_PIPELINE_TABLE_MAX&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of tables allowed for any given pipeline instance. The value of this parameter cannot be changed. </p>

<p>Definition at line <a class="el" href="rte__pipeline_8h_source.html#l00232">232</a> of file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa107216ecaebb628afdf1f3861cb8d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_PIPELINE_PORT_IN_MAX&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of input ports allowed for any given pipeline instance. The value of this parameter cannot be changed. </p>

<p>Definition at line <a class="el" href="rte__pipeline_8h_source.html#l00564">564</a> of file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>

</div>
</div>
<a class="anchor" id="af8ae017901472b93f0d727f7663d788a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_PIPELINE_PORT_OUT_MAX&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of output ports allowed for any given pipeline instance. The value of this parameter cannot be changed. </p>

<p>Definition at line <a class="el" href="rte__pipeline_8h_source.html#l00696">696</a> of file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a690cec4a2e911968eb8036b333396f7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_pipeline_table_action_handler_hit)(struct rte_pipeline *p, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint64_t pkts_mask, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **entries, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table action handler on lookup hit</p>
<p>The action handler can decide to drop packets by resetting the associated packet bit in the pkts_mask parameter. In this case, the action handler is required not to free the packet buffer, which will be freed eventually by the pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">pkts</td><td>Burst of input packets specified as array of up to 64 pointers to struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> </td></tr>
    <tr><td class="paramname">pkts_mask</td><td>64-bit bitmask specifying which packets in the input burst are valid. When pkts_mask bit n is set, then element n of pkts array is pointing to a valid packet and element n of entries array is pointing to a valid table entry associated with the packet, with the association typically done by the table lookup operation. Otherwise, element n of pkts array and element n of entries array will not be accessed. </td></tr>
    <tr><td class="paramname">entries</td><td>Set of table entries specified as array of up to 64 pointers to struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> </td></tr>
    <tr><td class="paramname">arg</td><td>Opaque parameter registered by the user at the pipeline table creation time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a19">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a5">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a17">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__pipeline_8h_source.html#l00287">287</a> of file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>

</div>
</div>
<a class="anchor" id="a985a626a1682c9b73f280d3af5b0c161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_pipeline_table_action_handler_miss)(struct rte_pipeline *p, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint64_t pkts_mask, struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *entry, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table action handler on lookup miss</p>
<p>The action handler can decide to drop packets by resetting the associated packet bit in the pkts_mask parameter. In this case, the action handler is required not to free the packet buffer, which will be freed eventually by the pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">pkts</td><td>Burst of input packets specified as array of up to 64 pointers to struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> </td></tr>
    <tr><td class="paramname">pkts_mask</td><td>64-bit bitmask specifying which packets in the input burst are valid. When pkts_mask bit n is set, then element n of pkts array is pointing to a valid packet. Otherwise, element n of pkts array will not be accessed. </td></tr>
    <tr><td class="paramname">entry</td><td>Single table entry associated with all the valid packets from the input burst, specified as pointer to struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a>. This entry is the pipeline table default entry that is associated by the table lookup operation with the input packets that have resulted in lookup miss. </td></tr>
    <tr><td class="paramname">arg</td><td>Opaque parameter registered by the user at the pipeline table creation time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>

<p>Definition at line <a class="el" href="rte__pipeline_8h_source.html#l00323">323</a> of file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>

</div>
</div>
<a class="anchor" id="a07e46798593a5225761fda51abd2e0e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_pipeline_port_in_action_handler)(struct rte_pipeline *p, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint32_t n, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline input port action handler</p>
<p>The action handler can decide to drop packets by resetting the associated packet bit in the pkts_mask parameter. In this case, the action handler is required not to free the packet buffer, which will be freed eventually by the pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">pkts</td><td>Burst of input packets specified as array of up to 64 pointers to struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> </td></tr>
    <tr><td class="paramname">n</td><td>Number of packets in the input burst. This parameter specifies that elements 0 to (n-1) of pkts array are valid. </td></tr>
    <tr><td class="paramname">arg</td><td>Opaque parameter registered by the user at the pipeline table creation time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a6">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__pipeline_8h_source.html#l00588">588</a> of file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6c1be123ee7fbf0f0e8aacd79bc9b10d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_pipeline_port_out_action_handler)(struct rte_pipeline *p, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **pkts, uint64_t pkts_mask, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline output port action handler</p>
<p>The action handler can decide to drop packets by resetting the associated packet bit in the pkts_mask parameter. In this case, the action handler is required not to free the packet buffer, which will be freed eventually by the pipeline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">pkts</td><td>Burst of input packets specified as array of up to 64 pointers to struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> </td></tr>
    <tr><td class="paramname">pkts_mask</td><td>64-bit bitmask specifying which packets in the input burst are valid. When pkts_mask bit n is set, then element n of pkts array is pointing to a valid packet. Otherwise, element n of pkts array will not be accessed. </td></tr>
    <tr><td class="paramname">arg</td><td>Opaque parameter registered by the user at the pipeline table creation time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>

<p>Definition at line <a class="el" href="rte__pipeline_8h_source.html#l00721">721</a> of file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a6376b240935404d998f003d113651572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__pipeline_8h.html#a6376b240935404d998f003d113651572">rte_pipeline_action</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserved actions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6376b240935404d998f003d113651572af41296546f2a86d1f8f1848010c7c111"></a>RTE_PIPELINE_ACTION_DROP</em>&#160;</td><td class="fielddoc">
<p>Drop the packet </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6376b240935404d998f003d113651572ac8c58609785d844989b7d9eb1e6db8aa"></a>RTE_PIPELINE_ACTION_PORT</em>&#160;</td><td class="fielddoc">
<p>Send packet to output port </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6376b240935404d998f003d113651572a5dc23d641b483615ea475152ac7ab7f4"></a>RTE_PIPELINE_ACTION_PORT_META</em>&#160;</td><td class="fielddoc">
<p>Send packet to output port read from packet meta-data </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6376b240935404d998f003d113651572abafaf6276afcfcb170a2f7aa44c21048"></a>RTE_PIPELINE_ACTION_TABLE</em>&#160;</td><td class="fielddoc">
<p>Send packet to table </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6376b240935404d998f003d113651572a34f0fbbbdce5f615d27dc0105b1640c3"></a>RTE_PIPELINE_ACTIONS</em>&#160;</td><td class="fielddoc">
<p>Number of reserved actions </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="rte__pipeline_8h_source.html#l00209">209</a> of file <a class="el" href="rte__pipeline_8h_source.html">rte_pipeline.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad650149ed178057bfb54bda0b6e39e05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_pipeline* rte_pipeline_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__params.html">rte_pipeline_params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline create</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Parameters for pipeline creation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to pipeline instance on success or NULL otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a17">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a26">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a11">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a13">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a25">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a85ce2e4661092748a84409a1d6eae14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline free</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a22">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a31">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a16">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a18">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a30">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ada72ecd95a1a181d1d555dd699f95475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_check </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline consistency check</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a34">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a45">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a40">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a31">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a44">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4570eddec506f947c5c91cb2334a2eda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_run </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of packets read and processed </dd></dl>

</div>
</div>
<a class="anchor" id="ac26447a6b0c4b1ec218a9133d790fef1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_flush </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline flush</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a35">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a46">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a41">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a32">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a45">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af1cb4d7ac4516443e6f9d82a4beebed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_table_create </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__params.html">rte_pipeline_table_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table create</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">params</td><td>Parameters for pipeline table creation </td></tr>
    <tr><td class="paramname">table_id</td><td>Table ID. Valid only within the scope of table IDs of the current pipeline. Only returned after a successful invocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a31">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a39">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a37">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a24">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a38">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8980fbc2a51d6dc8041b798ea5172318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_table_default_entry_add </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *&#160;</td>
          <td class="paramname"><em>default_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **&#160;</td>
          <td class="paramname"><em>default_entry_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table default entry add</p>
<p>The contents of the table default entry is updated with the provided actions and meta-data. When the default entry is not configured (by using this function), the built-in default entry has the action "Drop" and meta-data set to all-zeros.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">table_id</td><td>Table ID (returned by previous invocation of pipeline table create) </td></tr>
    <tr><td class="paramname">default_entry</td><td>New contents for the table default entry </td></tr>
    <tr><td class="paramname">default_entry_ptr</td><td>On successful invocation, pointer to the default table entry which can be used for further read-write accesses to this table entry. This pointer is valid until the default entry is deleted or re-added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a49">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a45">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a29">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a53">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac83e9cacb91301a7425694f32249e050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_table_default_entry_delete </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table default entry delete</p>
<p>The new contents of the table default entry is set to reserved action "Drop
the packet" with meta-data cleared (i.e. set to all-zeros).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">table_id</td><td>Table ID (returned by previous invocation of pipeline table create) </td></tr>
    <tr><td class="paramname">entry</td><td>On successful invocation, when entry points to a valid buffer, the previous contents of the table default entry (as it was just before the delete operation) is copied to this buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a50">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a46">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a54">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0e90e4a54b6467deb9b449bf8bd5cab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_table_entry_add </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>key_found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **&#160;</td>
          <td class="paramname"><em>entry_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table entry add</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">table_id</td><td>Table ID (returned by previous invocation of pipeline table create) </td></tr>
    <tr><td class="paramname">key</td><td>Table entry key </td></tr>
    <tr><td class="paramname">entry</td><td>New contents for the table entry identified by key </td></tr>
    <tr><td class="paramname">key_found</td><td>On successful invocation, set to TRUE (value different than 0) if key was already present in the table before the add operation and to FALSE (value 0) if not </td></tr>
    <tr><td class="paramname">entry_ptr</td><td>On successful invocation, pointer to the table entry associated with key. This can be used for further read-write accesses to this table entry and is valid until the key is deleted from the table or re-added (usually for associating different actions and/or action meta-data to the current key) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a38">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a44">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a43">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a51">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a946f0d5610d152c1e6f641928c4f0743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_table_entry_delete </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>key_found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table entry delete</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">table_id</td><td>Table ID (returned by previous invocation of pipeline table create) </td></tr>
    <tr><td class="paramname">key</td><td>Table entry key </td></tr>
    <tr><td class="paramname">key_found</td><td>On successful invocation, set to TRUE (value different than 0) if key was found in the table before the delete operation and to FALSE (value 0) if not </td></tr>
    <tr><td class="paramname">entry</td><td>On successful invocation, when key is found in the table and entry points to a valid buffer, the table entry contents (as it was before the delete was performed) is copied to this buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a40">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a44">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a52">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a95cffe0cc5ee976c84d57af72b570523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_table_entry_add_bulk </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>key_found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **&#160;</td>
          <td class="paramname"><em>entries_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table entry add bulk</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">table_id</td><td>Table ID (returned by previous invocation of pipeline table create) </td></tr>
    <tr><td class="paramname">keys</td><td>Array containing table entry keys </td></tr>
    <tr><td class="paramname">entries</td><td>Array containung new contents for every table entry identified by key </td></tr>
    <tr><td class="paramname">n_keys</td><td>Number of keys to add </td></tr>
    <tr><td class="paramname">key_found</td><td>On successful invocation, key_found for every item in the array is set to TRUE (value different than 0) if key was already present in the table before the add operation and to FALSE (value 0) if not </td></tr>
    <tr><td class="paramname">entries_ptr</td><td>On successful invocation, array *entries_ptr stores pointer to every table entry associated with key. This can be used for further read-write accesses to this table entry and is valid until the key is deleted from the table or re-added (usually for associating different actions and/or action meta-data to the current key) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a46">ip_pipeline/pipeline/pipeline_firewall_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a20c2e2a595e117cd9ae797fee6ab253a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_table_entry_delete_bulk </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>key_found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__entry.html">rte_pipeline_table_entry</a> **&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline table entry delete bulk</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">table_id</td><td>Table ID (returned by previous invocation of pipeline table create) </td></tr>
    <tr><td class="paramname">keys</td><td>Array containing table entry keys </td></tr>
    <tr><td class="paramname">n_keys</td><td>Number of keys to delete </td></tr>
    <tr><td class="paramname">key_found</td><td>On successful invocation, key_found for every item in the array is set to TRUE (value different than 0) if key was found in the table before the delete operation and to FALSE (value 0) if not </td></tr>
    <tr><td class="paramname">entries</td><td>If entries pointer is NULL, this pointer is ignored for every entry found. Else, after successful invocation, if specific key is found in the table and entry points to a valid buffer, the table entry contents (as it was before the delete was performed) is copied to this buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a48">ip_pipeline/pipeline/pipeline_firewall_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a3fb68f21e8a212dcf698077b66e53e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_table_stats_read </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__table__stats.html">rte_pipeline_table_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read pipeline table stats.</p>
<p>This function reads table statistics identified by <em>table_id</em> of given pipeline <em>p</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance. </td></tr>
    <tr><td class="paramname">table_id</td><td>Port ID what stats will be returned. </td></tr>
    <tr><td class="paramname">stats</td><td>Statistics buffer. </td></tr>
    <tr><td class="paramname">clear</td><td>If not 0 clear stats after reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_common_be_8c-example.html#a3">ip_pipeline/pipeline/pipeline_common_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab0c0f093519ccc9fbb76e7c5696fd266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_port_in_create </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__port__in__params.html">rte_pipeline_port_in_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline input port create</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">params</td><td>Parameters for pipeline input port creation </td></tr>
    <tr><td class="paramname">port_id</td><td>Input port ID. Valid only within the scope of input port IDs of the current pipeline. Only returned after a successful invocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a21">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a30">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a15">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a17">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a29">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adc4634b81c75f146f3afac17dbbe727c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_port_in_connect_to_table </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline input port connect to table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">port_id</td><td>Port ID (returned by previous invocation of pipeline input port create) </td></tr>
    <tr><td class="paramname">table_id</td><td>Table ID (returned by previous invocation of pipeline table create) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a32">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a40">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a38">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a25">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a42">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af8a48f99a99731883005dfe93c5406e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_port_in_enable </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline input port enable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">port_id</td><td>Port ID (returned by previous invocation of pipeline input port create) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_common_be_8c-example.html#a4">ip_pipeline/pipeline/pipeline_common_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a33">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a41">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a39">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a30">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a43">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6b3750798dfd9a03093790d52dd94aca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_port_in_disable </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline input port disable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">port_id</td><td>Port ID (returned by previous invocation of pipeline input port create) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_common_be_8c-example.html#a5">ip_pipeline/pipeline/pipeline_common_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a790da0e2e134063df3eaa55bf6b70342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_port_in_stats_read </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__port__in__stats.html">rte_pipeline_port_in_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read pipeline port in stats.</p>
<p>This function reads port in statistics identified by <em>port_id</em> of given pipeline <em>p</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance. </td></tr>
    <tr><td class="paramname">port_id</td><td>Port ID what stats will be returned. </td></tr>
    <tr><td class="paramname">stats</td><td>Statistics buffer. </td></tr>
    <tr><td class="paramname">clear</td><td>If not 0 clear stats after reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_common_be_8c-example.html#a1">ip_pipeline/pipeline/pipeline_common_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a247f58fe13cba38922ccf5c60a2f86bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_port_out_create </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__port__out__params.html">rte_pipeline_port_out_params</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pipeline output port create</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">params</td><td>Parameters for pipeline output port creation </td></tr>
    <tr><td class="paramname">port_id</td><td>Output port ID. Valid only within the scope of output port IDs of the current pipeline. Only returned after a successful invocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_firewall_be_8c-example.html#a24">ip_pipeline/pipeline/pipeline_firewall_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_actions_be_8c-example.html#a33">ip_pipeline/pipeline/pipeline_flow_actions_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_flow_classification_be_8c-example.html#a18">ip_pipeline/pipeline/pipeline_flow_classification_be.c</a>, <a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a20">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>, and <a class="el" href="ip_pipeline_2pipeline_2pipeline_routing_be_8c-example.html#a32">ip_pipeline/pipeline/pipeline_routing_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab831fab1384d2dc680140e08bd2acdff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_port_out_stats_read </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__pipeline__port__out__stats.html">rte_pipeline_port_out_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read pipeline port out stats.</p>
<p>This function reads port out statistics identified by <em>port_id</em> of given pipeline <em>p</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance. </td></tr>
    <tr><td class="paramname">port_id</td><td>Port ID what stats will be returned. </td></tr>
    <tr><td class="paramname">stats</td><td>Statistics buffer. </td></tr>
    <tr><td class="paramname">clear</td><td>If not 0 clear stats after reading. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_common_be_8c-example.html#a2">ip_pipeline/pipeline/pipeline_common_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2abe46f84e0842eec2f0f52083706fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_port_out_packet_insert </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Action handler packet insert to output port</p>
<p>This function can be called by any input/output port or table action handler to send a packet out through one of the pipeline output ports. This packet is generated by the action handler, i.e. this packet is not part of the burst of packets read from one of the pipeline input ports and currently processed by the pipeline (this packet is not an element of the pkts array input parameter of the action handler).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">port_id</td><td>Output port ID (returned by previous invocation of pipeline output port create) to send the packet specified by pkt </td></tr>
    <tr><td class="paramname">pkt</td><td>New packet generated by the action handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2pipeline_2pipeline_passthrough_be_8c-example.html#a5">ip_pipeline/pipeline/pipeline_passthrough_be.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adff1ad7418708c021c3fbfc672c72355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_ah_packet_hijack </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pkts_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Action handler packet hijack</p>
<p>This function can be called by any input/output port or table action handler to hijack selected packets from the burst of packets read from one of the pipeline input ports and currently processed by the pipeline. The hijacked packets are removed from any further pipeline processing, with the action handler now having the full ownership for these packets.</p>
<p>The action handler can further send the hijacked packets out through any pipeline output port by calling the rte_pipeline_ah_port_out_packet_insert() function. The action handler can also drop these packets by calling the <a class="el" href="rte__mbuf_8h.html#a1215458932900b7cd5192326fa4a6902">rte_pktmbuf_free()</a> function, although a better alternative is provided by the action handler using the <a class="el" href="rte__pipeline_8h.html#a2508aa80b0fe3e7cc6b163e783d32342">rte_pipeline_ah_packet_drop()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">pkts_mask</td><td>64-bit bitmask specifying which of the packets handed over for processing to the action handler is to be hijacked by the action handler. When pkts_mask bit n is set, then element n of the pkts array (input argument to the action handler) is hijacked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2508aa80b0fe3e7cc6b163e783d32342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_pipeline_ah_packet_drop </td>
          <td>(</td>
          <td class="paramtype">struct rte_pipeline *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>pkts_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Action handler packet drop</p>
<p>This function is called by the pipeline action handlers (port in/out, table) to drop the packets selected using packet mask.</p>
<p>This function can be called by any input/output port or table action handler to drop selected packets from the burst of packets read from one of the pipeline input ports and currently processed by the pipeline. The dropped packets are removed from any further pipeline processing and the packet buffers are eventually freed to their buffer pool.</p>
<p>This function updates the drop statistics counters correctly, therefore the recommended approach for dropping packets by the action handlers is to call this function as opposed to the action handler hijacking the packets first and then dropping them invisibly to the pipeline (by using the <a class="el" href="rte__mbuf_8h.html#a1215458932900b7cd5192326fa4a6902">rte_pktmbuf_free()</a> function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Handle to pipeline instance </td></tr>
    <tr><td class="paramname">pkts_mask</td><td>64-bit bitmask specifying which of the packets handed over for processing to the action handler is to be dropped by the action handler. When pkts_mask bit n is set, then element n of the pkts array (input argument to the action handler) is dropped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, error code otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
