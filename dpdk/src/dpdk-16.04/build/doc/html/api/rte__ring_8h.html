<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DPDK: lib/librte_ring/rte_ring.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">16.04.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_2154f83b08d9713661fee356762316ea.html">librte_ring</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_ring.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;sys/queue.h&gt;</code><br/>
<code>#include &lt;errno.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__lcore_8h_source.html">rte_lcore.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__atomic_8h_source.html">rte_atomic.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__branch__prediction_8h_source.html">rte_branch_prediction.h</a>&gt;</code><br/>
</div>
<p><a href="rte__ring_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ring.html">rte_ring</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ring_1_1prod.html">rte_ring::prod</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ring_1_1cons.html">rte_ring::cons</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2e508ee16359c5851fed8ff7a24cca01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a2e508ee16359c5851fed8ff7a24cca01">RTE_RING_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a2e508ee16359c5851fed8ff7a24cca01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eeb81750c06f5408679b65a1c9599ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a7eeb81750c06f5408679b65a1c9599ab">RTE_RING_PAUSE_REP_COUNT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a7eeb81750c06f5408679b65a1c9599ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127c66adbeab4653a47649993b94f35b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a127c66adbeab4653a47649993b94f35b">RING_F_SP_ENQ</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a127c66adbeab4653a47649993b94f35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a61b2f94cdf65b3a6ac146c492fb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a421a61b2f94cdf65b3a6ac146c492fb9">RING_F_SC_DEQ</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a421a61b2f94cdf65b3a6ac146c492fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90991a1bc346f7e71066578e4b1efc71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a90991a1bc346f7e71066578e4b1efc71">RTE_RING_QUOT_EXCEED</a>&#160;&#160;&#160;(1 &lt;&lt; 31)</td></tr>
<tr class="separator:a90991a1bc346f7e71066578e4b1efc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc92053129fb9aff3e9ced08f3a834"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aeecc92053129fb9aff3e9ced08f3a834">RTE_RING_SZ_MASK</a>&#160;&#160;&#160;(unsigned)(0x0fffffff)</td></tr>
<tr class="separator:aeecc92053129fb9aff3e9ced08f3a834"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac29f8523d355c107377858bdeb468486"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#ac29f8523d355c107377858bdeb468486">rte_ring_get_memsize</a> (unsigned count)</td></tr>
<tr class="separator:ac29f8523d355c107377858bdeb468486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a44f25853c926ac1b29562857244366"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a7a44f25853c926ac1b29562857244366">rte_ring_init</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, const char *name, unsigned count, unsigned flags)</td></tr>
<tr class="separator:a7a44f25853c926ac1b29562857244366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5556487d8ec76cacfc059b66d8b77c98"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a5556487d8ec76cacfc059b66d8b77c98">rte_ring_create</a> (const char *name, unsigned count, int socket_id, unsigned flags)</td></tr>
<tr class="separator:a5556487d8ec76cacfc059b66d8b77c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564e012c1eb4ae08f9eea3acfd08b377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a564e012c1eb4ae08f9eea3acfd08b377">rte_ring_free</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a564e012c1eb4ae08f9eea3acfd08b377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9429aef41021ea93aded578b548b2e49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a9429aef41021ea93aded578b548b2e49">rte_ring_set_water_mark</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, unsigned count)</td></tr>
<tr class="separator:a9429aef41021ea93aded578b548b2e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c464281266543ebc0766902467c69b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a09c464281266543ebc0766902467c69b">rte_ring_dump</a> (FILE *f, const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a09c464281266543ebc0766902467c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243d2eee25d957fd846f30981d675151"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a243d2eee25d957fd846f30981d675151">rte_ring_mp_enqueue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a243d2eee25d957fd846f30981d675151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edf3304fd8532a9a645a37aa8c124ce"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a3edf3304fd8532a9a645a37aa8c124ce">rte_ring_sp_enqueue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a3edf3304fd8532a9a645a37aa8c124ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5b9e5f047ff9f55c7b7b12203f3dd7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a9c5b9e5f047ff9f55c7b7b12203f3dd7">rte_ring_enqueue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a9c5b9e5f047ff9f55c7b7b12203f3dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0e1418101d97ba9c318e44fae64cbf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a2d0e1418101d97ba9c318e44fae64cbf">rte_ring_mp_enqueue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *obj)</td></tr>
<tr class="separator:a2d0e1418101d97ba9c318e44fae64cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644b1d6866fed20f0a5711e63ecefc38"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a644b1d6866fed20f0a5711e63ecefc38">rte_ring_sp_enqueue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *obj)</td></tr>
<tr class="separator:a644b1d6866fed20f0a5711e63ecefc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5649c0f53bac7c3a47bd8b75f0774815"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a5649c0f53bac7c3a47bd8b75f0774815">rte_ring_enqueue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *obj)</td></tr>
<tr class="separator:a5649c0f53bac7c3a47bd8b75f0774815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb59ee9b3e543686b6d2ed4eb540800e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aeb59ee9b3e543686b6d2ed4eb540800e">rte_ring_mc_dequeue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned n)</td></tr>
<tr class="separator:aeb59ee9b3e543686b6d2ed4eb540800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac8ee1c24db28362b48358cce8e5005"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a7ac8ee1c24db28362b48358cce8e5005">rte_ring_sc_dequeue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a7ac8ee1c24db28362b48358cce8e5005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa783f1ffa07e03ed6a9e29d9bb03c52a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aa783f1ffa07e03ed6a9e29d9bb03c52a">rte_ring_dequeue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned n)</td></tr>
<tr class="separator:aa783f1ffa07e03ed6a9e29d9bb03c52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d68780bade7c7ba3762d4ad5f5d5d3e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a2d68780bade7c7ba3762d4ad5f5d5d3e">rte_ring_mc_dequeue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_p)</td></tr>
<tr class="separator:a2d68780bade7c7ba3762d4ad5f5d5d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242877d9dc94b252277d6336c31b53ae"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a242877d9dc94b252277d6336c31b53ae">rte_ring_sc_dequeue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_p)</td></tr>
<tr class="separator:a242877d9dc94b252277d6336c31b53ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946f183cd036dc4687e58cde0f8e4a14"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a946f183cd036dc4687e58cde0f8e4a14">rte_ring_dequeue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_p)</td></tr>
<tr class="separator:a946f183cd036dc4687e58cde0f8e4a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06554a79e893291d4734507b3c599a21"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a06554a79e893291d4734507b3c599a21">rte_ring_full</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a06554a79e893291d4734507b3c599a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a7cda8ef5a62ee0a286c11d45d1bf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#abf9a7cda8ef5a62ee0a286c11d45d1bf">rte_ring_empty</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:abf9a7cda8ef5a62ee0a286c11d45d1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8376d2c6e609707d52032860880b34"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#abc8376d2c6e609707d52032860880b34">rte_ring_count</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:abc8376d2c6e609707d52032860880b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fe2e810cf4015bb95023c54e18b73a"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aa6fe2e810cf4015bb95023c54e18b73a">rte_ring_free_count</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:aa6fe2e810cf4015bb95023c54e18b73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfcef0ad324fcc4c03bcb59cd7e867f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a7bfcef0ad324fcc4c03bcb59cd7e867f">rte_ring_list_dump</a> (FILE *f)</td></tr>
<tr class="separator:a7bfcef0ad324fcc4c03bcb59cd7e867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26dd65732f16f720eca5e1aa94e2a8a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#ad26dd65732f16f720eca5e1aa94e2a8a">rte_ring_lookup</a> (const char *name)</td></tr>
<tr class="separator:ad26dd65732f16f720eca5e1aa94e2a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a1264cea532cf85525587701dc2424"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a52a1264cea532cf85525587701dc2424">rte_ring_mp_enqueue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a52a1264cea532cf85525587701dc2424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bf9c28ffd98485abed7445c4d6ab07"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#ad8bf9c28ffd98485abed7445c4d6ab07">rte_ring_sp_enqueue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:ad8bf9c28ffd98485abed7445c4d6ab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47abfd362ce12482690d2982b6e20f4"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#ae47abfd362ce12482690d2982b6e20f4">rte_ring_enqueue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:ae47abfd362ce12482690d2982b6e20f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579faf6057cc28610c4fcef4bbe5708c"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a579faf6057cc28610c4fcef4bbe5708c">rte_ring_mc_dequeue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a579faf6057cc28610c4fcef4bbe5708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdbfc074c1af23cf7e117437ac7f5f5"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a0bdbfc074c1af23cf7e117437ac7f5f5">rte_ring_sc_dequeue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a0bdbfc074c1af23cf7e117437ac7f5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e9554955e649e3d24d50588b2b4c5c"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a15e9554955e649e3d24d50588b2b4c5c">rte_ring_dequeue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a15e9554955e649e3d24d50588b2b4c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Ring</p>
<p>The Ring Manager is a fixed-size queue, implemented as a table of pointers. Head and tail pointers are modified atomically, allowing concurrent access to it. It has the following features:</p>
<ul>
<li>FIFO (First In First Out)</li>
<li>Maximum size is fixed; the pointers are stored in a table.</li>
<li>Lockless implementation.</li>
<li>Multi- or single-consumer dequeue.</li>
<li>Multi- or single-producer enqueue.</li>
<li>Bulk dequeue.</li>
<li>Bulk enqueue.</li>
</ul>
<p>Note: the ring implementation is not preemptable. A lcore must not be interrupted by another task that uses the same ring. </p>

<p>Definition in file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a2e508ee16359c5851fed8ff7a24cca01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_RING_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum length of a ring name. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="l2fwd-ivshmem_2host_2host_8c-example.html#a30">l2fwd-ivshmem/host/host.c</a>, and <a class="el" href="quota_watermark_2qw_2init_8c-example.html#a17">quota_watermark/qw/init.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00129">129</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7eeb81750c06f5408679b65a1c9599ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_RING_PAUSE_REP_COUNT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield after pause num of times, no yield if RTE_RING_PAUSE_REP not defined. </p>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00133">133</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a127c66adbeab4653a47649993b94f35b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RING_F_SP_ENQ&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default enqueue is "single-producer". </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2init_8c-example.html#a33">ip_pipeline/init.c</a>, <a class="el" href="l2fwd-ivshmem_2host_2host_8c-example.html#a48">l2fwd-ivshmem/host/host.c</a>, <a class="el" href="load_balancer_2init_8c-example.html#a14">load_balancer/init.c</a>, <a class="el" href="multi_process_2client_server_mp_2mp_server_2init_8c-example.html#a15">multi_process/client_server_mp/mp_server/init.c</a>, <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a20">multi_process/l2fwd_fork/main.c</a>, <a class="el" href="packet_ordering_2main_8c-example.html#a44">packet_ordering/main.c</a>, <a class="el" href="performance-thread_2l3fwd-thread_2main_8c-example.html#a65">performance-thread/l3fwd-thread/main.c</a>, <a class="el" href="qos_sched_2init_8c-example.html#a43">qos_sched/init.c</a>, <a class="el" href="quota_watermark_2qw_2init_8c-example.html#a20">quota_watermark/qw/init.c</a>, and <a class="el" href="vhost_2main_8c-example.html#a137">vhost/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00188">188</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a421a61b2f94cdf65b3a6ac146c492fb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RING_F_SC_DEQ&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default dequeue is "single-consumer". </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="distributor_2main_8c-example.html#a47">distributor/main.c</a>, <a class="el" href="ip_pipeline_2init_8c-example.html#a32">ip_pipeline/init.c</a>, <a class="el" href="l2fwd-ivshmem_2host_2host_8c-example.html#a49">l2fwd-ivshmem/host/host.c</a>, <a class="el" href="load_balancer_2init_8c-example.html#a15">load_balancer/init.c</a>, <a class="el" href="multi_process_2client_server_mp_2mp_server_2init_8c-example.html#a16">multi_process/client_server_mp/mp_server/init.c</a>, <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a21">multi_process/l2fwd_fork/main.c</a>, <a class="el" href="packet_ordering_2main_8c-example.html#a45">packet_ordering/main.c</a>, <a class="el" href="performance-thread_2l3fwd-thread_2main_8c-example.html#a66">performance-thread/l3fwd-thread/main.c</a>, <a class="el" href="qos_sched_2init_8c-example.html#a44">qos_sched/init.c</a>, <a class="el" href="quota_watermark_2qw_2init_8c-example.html#a21">quota_watermark/qw/init.c</a>, and <a class="el" href="vhost_2main_8c-example.html#a138">vhost/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00189">189</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90991a1bc346f7e71066578e4b1efc71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_RING_QUOT_EXCEED&#160;&#160;&#160;(1 &lt;&lt; 31)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quota exceed for burst ops </p>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00190">190</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeecc92053129fb9aff3e9ced08f3a834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_RING_SZ_MASK&#160;&#160;&#160;(unsigned)(0x0fffffff)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ring size mask </p>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00191">191</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac29f8523d355c107377858bdeb468486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rte_ring_get_memsize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the memory size needed for a ring</p>
<p>This function returns the number of bytes needed for a ring, given the number of elements in it. This value is the sum of the size of the structure <a class="el" href="structrte__ring.html">rte_ring</a> and the size of the memory needed by the objects pointers. The value is aligned to a cache line size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of elements in the ring (must be a power of 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The memory size needed for the ring on success.</li>
<li>-EINVAL if count is not a power of 2. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a7a44f25853c926ac1b29562857244366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_ring_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a ring structure.</p>
<p>Initialize a ring structure in memory pointed by "r". The size of the memory area must be large enough to store the ring structure and the object table. It is advised to use <a class="el" href="rte__ring_8h.html#ac29f8523d355c107377858bdeb468486">rte_ring_get_memsize()</a> to get the appropriate size.</p>
<p>The ring size is set to <em>count</em>, which must be a power of two. Water marking is disabled by default. The real usable ring size is <em>count-1</em> instead of <em>count</em> to differentiate a free ring from an empty ring.</p>
<p>The ring is not added in RTE_TAILQ_RING global list. Indeed, the memory given by the caller may not be shareable among dpdk processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The pointer to the ring structure followed by the objects table. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the ring. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the ring (must be a power of 2). </td></tr>
    <tr><td class="paramname">flags</td><td>An OR of the following:<ul>
<li>RING_F_SP_ENQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a5649c0f53bac7c3a47bd8b75f0774815">rte_ring_enqueue()</a></code> or <code><a class="el" href="rte__ring_8h.html#a9c5b9e5f047ff9f55c7b7b12203f3dd7">rte_ring_enqueue_bulk()</a></code> is "single-producer". Otherwise, it is "multi-producers".</li>
<li>RING_F_SC_DEQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a946f183cd036dc4687e58cde0f8e4a14">rte_ring_dequeue()</a></code> or <code><a class="el" href="rte__ring_8h.html#aa783f1ffa07e03ed6a9e29d9bb03c52a">rte_ring_dequeue_bulk()</a></code> is "single-consumer". Otherwise, it is "multi-consumers". </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative value on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5556487d8ec76cacfc059b66d8b77c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__ring.html">rte_ring</a>* rte_ring_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new ring named <em>name</em> in memory.</p>
<p>This function uses <code>memzone_reserve()</code> to allocate memory. Then it calls <a class="el" href="rte__ring_8h.html#a7a44f25853c926ac1b29562857244366">rte_ring_init()</a> to initialize an empty ring.</p>
<p>The new ring size is set to <em>count</em>, which must be a power of two. Water marking is disabled by default. The real usable ring size is <em>count-1</em> instead of <em>count</em> to differentiate a free ring from an empty ring.</p>
<p>The ring is added in RTE_TAILQ_RING list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the ring. </td></tr>
    <tr><td class="paramname">count</td><td>The size of the ring (must be a power of 2). </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>An OR of the following:<ul>
<li>RING_F_SP_ENQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a5649c0f53bac7c3a47bd8b75f0774815">rte_ring_enqueue()</a></code> or <code><a class="el" href="rte__ring_8h.html#a9c5b9e5f047ff9f55c7b7b12203f3dd7">rte_ring_enqueue_bulk()</a></code> is "single-producer". Otherwise, it is "multi-producers".</li>
<li>RING_F_SC_DEQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a946f183cd036dc4687e58cde0f8e4a14">rte_ring_dequeue()</a></code> or <code><a class="el" href="rte__ring_8h.html#aa783f1ffa07e03ed6a9e29d9bb03c52a">rte_ring_dequeue_bulk()</a></code> is "single-consumer". Otherwise, it is "multi-consumers". </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the pointer to the new allocated ring. NULL on error with rte_errno set appropriately. Possible errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to <a class="el" href="structrte__config.html">rte_config</a> structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - count provided is not a power of 2</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="distributor_2main_8c-example.html#a46">distributor/main.c</a>, <a class="el" href="ip_pipeline_2init_8c-example.html#a34">ip_pipeline/init.c</a>, <a class="el" href="l2fwd-ivshmem_2host_2host_8c-example.html#a47">l2fwd-ivshmem/host/host.c</a>, <a class="el" href="load_balancer_2init_8c-example.html#a13">load_balancer/init.c</a>, <a class="el" href="multi_process_2client_server_mp_2mp_server_2init_8c-example.html#a14">multi_process/client_server_mp/mp_server/init.c</a>, <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a17">multi_process/l2fwd_fork/main.c</a>, <a class="el" href="multi_process_2simple_mp_2main_8c-example.html#a9">multi_process/simple_mp/main.c</a>, <a class="el" href="packet_ordering_2main_8c-example.html#a43">packet_ordering/main.c</a>, <a class="el" href="performance-thread_2common_2lthread_tls_8c-example.html#a2">performance-thread/common/lthread_tls.c</a>, <a class="el" href="performance-thread_2l3fwd-thread_2main_8c-example.html#a64">performance-thread/l3fwd-thread/main.c</a>, <a class="el" href="qos_sched_2init_8c-example.html#a42">qos_sched/init.c</a>, <a class="el" href="quota_watermark_2qw_2init_8c-example.html#a18">quota_watermark/qw/init.c</a>, and <a class="el" href="vhost_2main_8c-example.html#a135">vhost/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a564e012c1eb4ae08f9eea3acfd08b377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_ring_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-allocate all memory used by the ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Ring to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9429aef41021ea93aded578b548b2e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_ring_set_water_mark </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the high water mark.</p>
<p>If <em>count</em> is 0, water marking is disabled. Otherwise, it is set to the <em>count</em> value. The <em>count</em> value must be greater than 0 and less than the ring size.</p>
<p>This function can be called at any time (not necessarily at initialization).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">count</td><td>The new water mark value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; water mark changed.</li>
<li>-EINVAL: Invalid water mark value. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="quota_watermark_2qw_2init_8c-example.html#a24">quota_watermark/qw/init.c</a>, and <a class="el" href="quota_watermark_2qwctl_2commands_8c-example.html#a2">quota_watermark/qwctl/commands.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a09c464281266543ebc0766902467c69b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_ring_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of the ring to the console.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="quota_watermark_2qwctl_2commands_8c-example.html#a3">quota_watermark/qwctl/commands.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a243d2eee25d957fd846f30981d675151"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_mp_enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on the ring (multi-producers safe).</p>
<p>This function uses a "compare and set" instruction to move the producer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueue.</li>
<li>-EDQUOT: Quota exceeded. The objects have been enqueued, but the high water mark is exceeded.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue, no object is enqueued. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00778">778</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3edf3304fd8532a9a645a37aa8c124ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_sp_enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on a ring (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueued.</li>
<li>-EDQUOT: Quota exceeded. The objects have been enqueued, but the high water mark is exceeded.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="load_balancer_2runtime_8c-example.html#a2">load_balancer/runtime.c</a>, and <a class="el" href="qos_sched_2app_thread_8c-example.html#a10">qos_sched/app_thread.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00800">800</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c5b9e5f047ff9f55c7b7b12203f3dd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on a ring.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueued.</li>
<li>-EDQUOT: Quota exceeded. The objects have been enqueued, but the high water mark is exceeded.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="l2fwd-ivshmem_2guest_2guest_8c-example.html#a6">l2fwd-ivshmem/guest/guest.c</a>, <a class="el" href="l2fwd-ivshmem_2host_2host_8c-example.html#a22">l2fwd-ivshmem/host/host.c</a>, <a class="el" href="multi_process_2client_server_mp_2mp_server_2main_8c-example.html#a8">multi_process/client_server_mp/mp_server/main.c</a>, and <a class="el" href="quota_watermark_2qw_2main_8c-example.html#a23">quota_watermark/qw/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00826">826</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d0e1418101d97ba9c318e44fae64cbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_mp_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue one object on a ring (multi-producers safe).</p>
<p>This function uses a "compare and set" instruction to move the producer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueued.</li>
<li>-EDQUOT: Quota exceeded. The objects have been enqueued, but the high water mark is exceeded.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="performance-thread_2common_2lthread_tls_8c-example.html#a3">performance-thread/common/lthread_tls.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00852">852</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a644b1d6866fed20f0a5711e63ecefc38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_sp_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue one object on a ring (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueued.</li>
<li>-EDQUOT: Quota exceeded. The objects have been enqueued, but the high water mark is exceeded.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2thread_8c-example.html#a2">ip_pipeline/thread.c</a>, <a class="el" href="ip_pipeline_2thread_fe_8c-example.html#a2">ip_pipeline/thread_fe.c</a>, and <a class="el" href="vhost_2main_8c-example.html#a96">vhost/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00871">871</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5649c0f53bac7c3a47bd8b75f0774815"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue one object on a ring.</p>
<p>This function calls the multi-producer or the single-producer version, depending on the default behaviour that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueued.</li>
<li>-EDQUOT: Quota exceeded. The objects have been enqueued, but the high water mark is exceeded.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a24">multi_process/l2fwd_fork/main.c</a>, and <a class="el" href="multi_process_2simple_mp_2mp_commands_8c-example.html#a2">multi_process/simple_mp/mp_commands.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00894">894</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb59ee9b3e543686b6d2ed4eb540800e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_mc_dequeue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring (multi-consumers safe).</p>
<p>This function uses a "compare and set" instruction to move the consumer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue; no object is dequeued. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00920">920</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ac8ee1c24db28362b48358cce8e5005"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_sc_dequeue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring (NOT multi-consumers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table, must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue; no object is dequeued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="load_balancer_2runtime_8c-example.html#a12">load_balancer/runtime.c</a>, and <a class="el" href="qos_sched_2app_thread_8c-example.html#a14">qos_sched/app_thread.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00941">941</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa783f1ffa07e03ed6a9e29d9bb03c52a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_dequeue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behaviour that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue, no object is dequeued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="l2fwd-ivshmem_2guest_2guest_8c-example.html#a10">l2fwd-ivshmem/guest/guest.c</a>, <a class="el" href="l2fwd-ivshmem_2host_2host_8c-example.html#a28">l2fwd-ivshmem/host/host.c</a>, and <a class="el" href="multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a23">multi_process/client_server_mp/mp_client/client.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00965">965</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d68780bade7c7ba3762d4ad5f5d5d3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_mc_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue one object from a ring (multi-consumers safe).</p>
<p>This function uses a "compare and set" instruction to move the consumer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue; no object is dequeued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="performance-thread_2common_2lthread_tls_8c-example.html#a5">performance-thread/common/lthread_tls.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l00989">989</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a242877d9dc94b252277d6336c31b53ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_sc_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue one object from a ring (NOT multi-consumers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue, no object is dequeued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2thread_8c-example.html#a1">ip_pipeline/thread.c</a>, <a class="el" href="ip_pipeline_2thread_fe_8c-example.html#a3">ip_pipeline/thread_fe.c</a>, and <a class="el" href="vhost_2main_8c-example.html#a95">vhost/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01007">1007</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a946f183cd036dc4687e58cde0f8e4a14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue one object from a ring.</p>
<p>This function calls the multi-consumers or the single-consumer version depending on the default behaviour that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue, no object is dequeued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a26">multi_process/l2fwd_fork/main.c</a>, and <a class="el" href="multi_process_2simple_mp_2main_8c-example.html#a3">multi_process/simple_mp/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01029">1029</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a06554a79e893291d4734507b3c599a21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_full </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if a ring is full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The ring is full.</li>
<li>0: The ring is not full. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01047">1047</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="abf9a7cda8ef5a62ee0a286c11d45d1bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if a ring is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The ring is empty.</li>
<li>0: The ring is not empty. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="quota_watermark_2qw_2main_8c-example.html#a26">quota_watermark/qw/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01064">1064</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc8376d2c6e609707d52032860880b34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_ring_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of entries in a ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the ring. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="l2fwd-ivshmem_2guest_2guest_8c-example.html#a7">l2fwd-ivshmem/guest/guest.c</a>, <a class="el" href="l2fwd-ivshmem_2host_2host_8c-example.html#a26">l2fwd-ivshmem/host/host.c</a>, <a class="el" href="multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a25">multi_process/client_server_mp/mp_client/client.c</a>, <a class="el" href="quota_watermark_2qw_2main_8c-example.html#a21">quota_watermark/qw/main.c</a>, and <a class="el" href="vhost_2main_8c-example.html#a108">vhost/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01080">1080</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa6fe2e810cf4015bb95023c54e18b73a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_ring_free_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of free entries in a ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of free entries in the ring. </dd></dl>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01096">1096</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7bfcef0ad324fcc4c03bcb59cd7e867f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_ring_list_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of all rings on the console</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad26dd65732f16f720eca5e1aa94e2a8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__ring.html">rte_ring</a>* rte_ring_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search a ring from its name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the ring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the ring matching the name, or NULL if not found, with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - required entry not available to return. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a16">multi_process/client_server_mp/mp_client/client.c</a>, <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a16">multi_process/l2fwd_fork/main.c</a>, <a class="el" href="multi_process_2simple_mp_2main_8c-example.html#a12">multi_process/simple_mp/main.c</a>, <a class="el" href="qos_sched_2init_8c-example.html#a41">qos_sched/init.c</a>, and <a class="el" href="quota_watermark_2qwctl_2commands_8c-example.html#a1">quota_watermark/qwctl/commands.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a52a1264cea532cf85525587701dc2424"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_ring_mp_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on the ring (multi-producers safe).</p>
<p>This function uses a "compare and set" instruction to move the producer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects enqueued. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01139">1139</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad8bf9c28ffd98485abed7445c4d6ab07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_ring_sp_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on a ring (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects enqueued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="performance-thread_2l3fwd-thread_2main_8c-example.html#a61">performance-thread/l3fwd-thread/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01158">1158</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae47abfd362ce12482690d2982b6e20f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_ring_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on a ring.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects enqueued. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="distributor_2main_8c-example.html#a32">distributor/main.c</a>, and <a class="el" href="packet_ordering_2main_8c-example.html#a28">packet_ordering/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01181">1181</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a579faf6057cc28610c4fcef4bbe5708c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_ring_mc_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring (multi-consumers safe). When the request objects are more than the available objects, only dequeue the actual number of objects</p>
<p>This function uses a "compare and set" instruction to move the consumer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects dequeued, 0 if ring is empty </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01208">1208</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0bdbfc074c1af23cf7e117437ac7f5f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_ring_sc_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring (NOT multi-consumers safe).When the request objects are more than the available objects, only dequeue the actual number of objects</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects dequeued, 0 if ring is empty </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="performance-thread_2l3fwd-thread_2main_8c-example.html#a59">performance-thread/l3fwd-thread/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01228">1228</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a class="anchor" id="a15e9554955e649e3d24d50588b2b4c5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_ring_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue multiple objects from a ring up to a maximum number.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behaviour that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Number of objects dequeued </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="distributor_2main_8c-example.html#a36">distributor/main.c</a>, <a class="el" href="packet_ordering_2main_8c-example.html#a30">packet_ordering/main.c</a>, and <a class="el" href="quota_watermark_2qw_2main_8c-example.html#a25">quota_watermark/qw/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__ring_8h_source.html#l01250">1250</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
