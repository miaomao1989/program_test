<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DPDK: performance-thread/pthread_shim/pthread_shim.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">16.04.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">performance-thread/pthread_shim/pthread_shim.c</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">/*-</span></div>
<div class="line"><span class="comment"> *   BSD LICENSE</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   Copyright(c) 2015 Intel Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *   All rights reserved.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   Redistribution and use in source and binary forms, with or without</span></div>
<div class="line"><span class="comment"> *   modification, are permitted provided that the following conditions</span></div>
<div class="line"><span class="comment"> *   are met:</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *     * Redistributions of source code must retain the above copyright</span></div>
<div class="line"><span class="comment"> *       notice, this list of conditions and the following disclaimer.</span></div>
<div class="line"><span class="comment"> *     * Redistributions in binary form must reproduce the above copyright</span></div>
<div class="line"><span class="comment"> *       notice, this list of conditions and the following disclaimer in</span></div>
<div class="line"><span class="comment"> *       the documentation and/or other materials provided with the</span></div>
<div class="line"><span class="comment"> *       distribution.</span></div>
<div class="line"><span class="comment"> *     * Neither the name of Intel Corporation nor the names of its</span></div>
<div class="line"><span class="comment"> *       contributors may be used to endorse or promote products derived</span></div>
<div class="line"><span class="comment"> *       from this software without specific prior written permission.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div>
<div class="line"><span class="comment"> *   &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div>
<div class="line"><span class="comment"> *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></div>
<div class="line"><span class="comment"> *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></div>
<div class="line"><span class="comment"> *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div>
<div class="line"><span class="comment"> *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></div>
<div class="line"><span class="comment"> *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></div>
<div class="line"><span class="comment"> *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></div>
<div class="line"><span class="comment"> *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div>
<div class="line"><span class="comment"> *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div>
<div class="line"><span class="comment"> *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sys/types.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;errno.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define __USE_GNU</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;sched.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;dlfcn.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rte__log_8h.html">rte_log.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;lthread_api.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;pthread_shim.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define RTE_LOGTYPE_PTHREAD_SHIM RTE_LOGTYPE_USER3</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define POSIX_ERRNO(x)  (x)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * this flag determines at run time if we override pthread</span></div>
<div class="line"><span class="comment"> * calls and map then to equivalent lthread calls</span></div>
<div class="line"><span class="comment"> * or of we call the standard pthread function</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">static</span> __thread <span class="keywordtype">int</span> <span class="keyword">override</span>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * this structures contains function pointers that will be</span></div>
<div class="line"><span class="comment"> * initialised to the loaded address of the real</span></div>
<div class="line"><span class="comment"> * pthread library API functions</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">struct </span>pthread_lib_funcs {</div>
<div class="line">int (*f_pthread_barrier_destroy)</div>
<div class="line">    (pthread_barrier_t *);</div>
<div class="line">int (*f_pthread_barrier_init)</div>
<div class="line">    (pthread_barrier_t *, <span class="keyword">const</span> pthread_barrierattr_t *, unsigned);</div>
<div class="line">int (*f_pthread_barrier_wait)</div>
<div class="line">    (pthread_barrier_t *);</div>
<div class="line">int (*f_pthread_cond_broadcast)</div>
<div class="line">    (pthread_cond_t *);</div>
<div class="line">int (*f_pthread_cond_destroy)</div>
<div class="line">    (pthread_cond_t *);</div>
<div class="line">int (*f_pthread_cond_init)</div>
<div class="line">    (pthread_cond_t *, <span class="keyword">const</span> pthread_condattr_t *);</div>
<div class="line">int (*f_pthread_cond_signal)</div>
<div class="line">    (pthread_cond_t *);</div>
<div class="line">int (*f_pthread_cond_timedwait)</div>
<div class="line">    (pthread_cond_t *, pthread_mutex_t *, <span class="keyword">const</span> <span class="keyword">struct </span>timespec *);</div>
<div class="line">int (*f_pthread_cond_wait)</div>
<div class="line">    (pthread_cond_t *, pthread_mutex_t *);</div>
<div class="line">int (*f_pthread_create)</div>
<div class="line">    (pthread_t *, <span class="keyword">const</span> pthread_attr_t *, <span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *);</div>
<div class="line">int (*f_pthread_detach)</div>
<div class="line">    (pthread_t);</div>
<div class="line">int (*f_pthread_equal)</div>
<div class="line">    (pthread_t, pthread_t);</div>
<div class="line">void (*f_pthread_exit)</div>
<div class="line">    (<span class="keywordtype">void</span> *);</div>
<div class="line"><span class="keywordtype">void</span> * (*f_pthread_getspecific)</div>
<div class="line">    (pthread_key_t);</div>
<div class="line">int (*f_pthread_getcpuclockid)</div>
<div class="line">    (pthread_t, clockid_t *);</div>
<div class="line">int (*f_pthread_join)</div>
<div class="line">    (pthread_t, <span class="keywordtype">void</span> **);</div>
<div class="line">int (*f_pthread_key_create)</div>
<div class="line">    (pthread_key_t *, void (*) (<span class="keywordtype">void</span> *));</div>
<div class="line">int (*f_pthread_key_delete)</div>
<div class="line">    (pthread_key_t);</div>
<div class="line">int (*f_pthread_mutex_destroy)</div>
<div class="line">    (pthread_mutex_t *__mutex);</div>
<div class="line">int (*f_pthread_mutex_init)</div>
<div class="line">    (pthread_mutex_t *__mutex, <span class="keyword">const</span> pthread_mutexattr_t *);</div>
<div class="line">int (*f_pthread_mutex_lock)</div>
<div class="line">    (pthread_mutex_t *__mutex);</div>
<div class="line">int (*f_pthread_mutex_trylock)</div>
<div class="line">    (pthread_mutex_t *__mutex);</div>
<div class="line">int (*f_pthread_mutex_timedlock)</div>
<div class="line">    (pthread_mutex_t *__mutex, <span class="keyword">const</span> <span class="keyword">struct </span>timespec *);</div>
<div class="line">int (*f_pthread_mutex_unlock)</div>
<div class="line">    (pthread_mutex_t *__mutex);</div>
<div class="line">int (*f_pthread_once)</div>
<div class="line">    (pthread_once_t *, void (*) (void));</div>
<div class="line">int (*f_pthread_rwlock_destroy)</div>
<div class="line">    (pthread_rwlock_t *__rwlock);</div>
<div class="line">int (*f_pthread_rwlock_init)</div>
<div class="line">    (pthread_rwlock_t *__rwlock, <span class="keyword">const</span> pthread_rwlockattr_t *);</div>
<div class="line">int (*f_pthread_rwlock_rdlock)</div>
<div class="line">    (pthread_rwlock_t *__rwlock);</div>
<div class="line">int (*f_pthread_rwlock_timedrdlock)</div>
<div class="line">    (pthread_rwlock_t *__rwlock, <span class="keyword">const</span> <span class="keyword">struct </span>timespec *);</div>
<div class="line">int (*f_pthread_rwlock_timedwrlock)</div>
<div class="line">    (pthread_rwlock_t *__rwlock, <span class="keyword">const</span> <span class="keyword">struct </span>timespec *);</div>
<div class="line">int (*f_pthread_rwlock_tryrdlock)</div>
<div class="line">    (pthread_rwlock_t *__rwlock);</div>
<div class="line">int (*f_pthread_rwlock_trywrlock)</div>
<div class="line">    (pthread_rwlock_t *__rwlock);</div>
<div class="line">int (*f_pthread_rwlock_unlock)</div>
<div class="line">    (pthread_rwlock_t *__rwlock);</div>
<div class="line">int (*f_pthread_rwlock_wrlock)</div>
<div class="line">    (pthread_rwlock_t *__rwlock);</div>
<div class="line">pthread_t (*f_pthread_self)</div>
<div class="line">    (void);</div>
<div class="line">int (*f_pthread_setspecific)</div>
<div class="line">    (pthread_key_t, <span class="keyword">const</span> <span class="keywordtype">void</span> *);</div>
<div class="line">int (*f_pthread_spin_init)</div>
<div class="line">    (pthread_spinlock_t *__spin, int);</div>
<div class="line">int (*f_pthread_spin_destroy)</div>
<div class="line">    (pthread_spinlock_t *__spin);</div>
<div class="line">int (*f_pthread_spin_lock)</div>
<div class="line">    (pthread_spinlock_t *__spin);</div>
<div class="line">int (*f_pthread_spin_trylock)</div>
<div class="line">    (pthread_spinlock_t *__spin);</div>
<div class="line">int (*f_pthread_spin_unlock)</div>
<div class="line">    (pthread_spinlock_t *__spin);</div>
<div class="line">int (*f_pthread_cancel)</div>
<div class="line">    (pthread_t);</div>
<div class="line">int (*f_pthread_setcancelstate)</div>
<div class="line">    (int, <span class="keywordtype">int</span> *);</div>
<div class="line">int (*f_pthread_setcanceltype)</div>
<div class="line">    (int, <span class="keywordtype">int</span> *);</div>
<div class="line">void (*f_pthread_testcancel)</div>
<div class="line">    (void);</div>
<div class="line">int (*f_pthread_getschedparam)</div>
<div class="line">    (pthread_t pthread, <span class="keywordtype">int</span> *, <span class="keyword">struct </span>sched_param *);</div>
<div class="line">int (*f_pthread_setschedparam)</div>
<div class="line">    (pthread_t, int, <span class="keyword">const</span> <span class="keyword">struct </span>sched_param *);</div>
<div class="line">int (*f_pthread_yield)</div>
<div class="line">    (void);</div>
<div class="line">int (*f_pthread_setaffinity_np)</div>
<div class="line">    (pthread_t thread, <span class="keywordtype">size_t</span> cpusetsize, <span class="keyword">const</span> cpu_set_t *cpuset);</div>
<div class="line">int (*f_nanosleep)</div>
<div class="line">    (<span class="keyword">const</span> <span class="keyword">struct </span>timespec *req, <span class="keyword">struct </span>timespec *rem);</div>
<div class="line">} _sys_pthread_funcs = {</div>
<div class="line">    .f_pthread_barrier_destroy = NULL,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * this macro obtains the loaded address of a library function</span></div>
<div class="line"><span class="comment"> * and saves it.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *__libc_dl_handle = RTLD_NEXT;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define get_addr_of_loaded_symbol(name) do {                \</span></div>
<div class="line"><span class="preprocessor">    char *error_str;                        \</span></div>
<div class="line"><span class="preprocessor">    _sys_pthread_funcs.f_##name = dlsym(__libc_dl_handle, (#name)); \</span></div>
<div class="line"><span class="preprocessor">    error_str = dlerror();                      \</span></div>
<div class="line"><span class="preprocessor">    if (error_str != NULL) {                    \</span></div>
<div class="line"><span class="preprocessor">        fprintf(stderr, &quot;%s\n&quot;, error_str);         \</span></div>
<div class="line"><span class="preprocessor">    }                               \</span></div>
<div class="line"><span class="preprocessor">} while (0)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * The constructor function initialises the</span></div>
<div class="line"><span class="comment"> * function pointers for pthread library functions</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">pthread_intercept_ctor(<span class="keywordtype">void</span>)__attribute__((constructor));</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">pthread_intercept_ctor(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">override</span> = 0;</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Get the original functions</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    get_addr_of_loaded_symbol(pthread_barrier_destroy);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_barrier_init);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_barrier_wait);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_cond_broadcast);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_cond_destroy);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_cond_init);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_cond_signal);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_cond_timedwait);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_cond_wait);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_create);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_detach);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_equal);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_exit);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_getspecific);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_getcpuclockid);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_join);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_key_create);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_key_delete);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_mutex_destroy);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_mutex_init);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_mutex_lock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_mutex_trylock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_mutex_timedlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_mutex_unlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_once);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_destroy);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_init);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_rdlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_timedrdlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_timedwrlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_tryrdlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_trywrlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_unlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_rwlock_wrlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_self);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_setspecific);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_spin_init);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_spin_destroy);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_spin_lock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_spin_trylock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_spin_unlock);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_cancel);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_setcancelstate);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_setcanceltype);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_testcancel);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_getschedparam);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_setschedparam);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_yield);</div>
<div class="line">    get_addr_of_loaded_symbol(pthread_setaffinity_np);</div>
<div class="line">    get_addr_of_loaded_symbol(nanosleep);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Enable/Disable pthread override</span></div>
<div class="line"><span class="comment"> * state</span></div>
<div class="line"><span class="comment"> *  0 disable</span></div>
<div class="line"><span class="comment"> *  1 enable</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> pthread_override_set(<span class="keywordtype">int</span> state)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">override</span> = state;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Return pthread override state</span></div>
<div class="line"><span class="comment"> * return</span></div>
<div class="line"><span class="comment"> *  0 disable</span></div>
<div class="line"><span class="comment"> *  1 enable</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">int</span> pthread_override_get(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">override</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * This macro is used to catch and log</span></div>
<div class="line"><span class="comment"> * invocation of stubs for unimplemented pthread</span></div>
<div class="line"><span class="comment"> * API functions.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="preprocessor">#define NOT_IMPLEMENTED do {                \</span></div>
<div class="line"><span class="preprocessor">    if (override) {                 \</span></div>
<div class="line"><span class="preprocessor">        RTE_LOG(WARNING,            \</span></div>
<div class="line"><span class="preprocessor">            PTHREAD_SHIM,           \</span></div>
<div class="line"><span class="preprocessor">            &quot;WARNING %s NOT IMPLEMENTED\n&quot;, \</span></div>
<div class="line"><span class="preprocessor">            __func__);          \</span></div>
<div class="line"><span class="preprocessor">    }                       \</span></div>
<div class="line"><span class="preprocessor">} while (0)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * pthread API override functions follow</span></div>
<div class="line"><span class="comment"> * Note in this example code only a subset of functions are</span></div>
<div class="line"><span class="comment"> * implemented.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The stub functions provided will issue a warning log</span></div>
<div class="line"><span class="comment"> * message if an unimplemented function is invoked</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_barrier_destroy(pthread_barrier_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_barrier_destroy(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">pthread_barrier_init(pthread_barrier_t *a,</div>
<div class="line">             <span class="keyword">const</span> pthread_barrierattr_t *b, <span class="keywordtype">unsigned</span> c)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_barrier_init(a, b, c);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_barrier_wait(pthread_barrier_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_barrier_wait(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_cond_broadcast(pthread_cond_t *cond)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line"></div>
<div class="line">        lthread_cond_broadcast(*(<span class="keyword">struct</span> lthread_cond **)cond);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_cond_broadcast(cond);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_mutex_destroy(pthread_mutex_t *mutex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_mutex_destroy(*(<span class="keyword">struct</span> lthread_mutex **)mutex);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_mutex_destroy(mutex);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_cond_destroy(pthread_cond_t *cond)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_cond_destroy(*(<span class="keyword">struct</span> lthread_cond **)cond);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_cond_destroy(cond);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_cond_init(pthread_cond_t *cond, <span class="keyword">const</span> pthread_condattr_t *attr)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_cond_init(NULL,</div>
<div class="line">                (<span class="keyword">struct</span> lthread_cond **)cond,</div>
<div class="line">                (<span class="keyword">const</span> <span class="keyword">struct</span> lthread_condattr *) attr);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_cond_init(cond, attr);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_cond_signal(pthread_cond_t *cond)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        lthread_cond_signal(*(<span class="keyword">struct</span> lthread_cond **)cond);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_cond_signal(cond);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">pthread_cond_timedwait(pthread_cond_t *__restrict cond,</div>
<div class="line">               pthread_mutex_t *__restrict mutex,</div>
<div class="line">               <span class="keyword">const</span> <span class="keyword">struct</span> timespec *__restrict time)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_cond_timedwait(cond, mutex, time);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        pthread_mutex_unlock(mutex);</div>
<div class="line">        <span class="keywordtype">int</span> rv = lthread_cond_wait(*(<span class="keyword">struct</span> lthread_cond **)cond, 0);</div>
<div class="line"></div>
<div class="line">        pthread_mutex_lock(mutex);</div>
<div class="line">        <span class="keywordflow">return</span> rv;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_cond_wait(cond, mutex);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">pthread_create(pthread_t *__restrict tid,</div>
<div class="line">        <span class="keyword">const</span> pthread_attr_t *__restrict attr,</div>
<div class="line">        <span class="keywordtype">void</span> *(func) (<span class="keywordtype">void</span> *),</div>
<div class="line">           <span class="keywordtype">void</span> *__restrict arg)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        <span class="keywordtype">int</span> lcore = -1;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (attr != NULL) {</div>
<div class="line">            <span class="comment">/* determine CPU being requested */</span></div>
<div class="line">            cpu_set_t cpuset;</div>
<div class="line"></div>
<div class="line">            CPU_ZERO(&amp;cpuset);</div>
<div class="line">            pthread_attr_getaffinity_np(attr,</div>
<div class="line">                        <span class="keyword">sizeof</span>(cpu_set_t),</div>
<div class="line">                        &amp;cpuset);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (CPU_COUNT(&amp;cpuset) != 1)</div>
<div class="line">                <span class="keywordflow">return</span> POSIX_ERRNO(EINVAL);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (lcore = 0; lcore &lt; LTHREAD_MAX_LCORES; lcore++) {</div>
<div class="line">                <span class="keywordflow">if</span> (!CPU_ISSET(lcore, &amp;cpuset))</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> lthread_create((<span class="keyword">struct</span> lthread **)tid, lcore,</div>
<div class="line">                      (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span> *))func, arg);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_create(tid, attr, func, arg);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_detach(pthread_t tid)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        <span class="keyword">struct </span>lthread *lt = (<span class="keyword">struct </span>lthread *)tid;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (lt == lthread_current())</div>
<div class="line">            lthread_detach();</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        NOT_IMPLEMENTED;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_detach(tid);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_equal(pthread_t a, pthread_t b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_equal(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> pthread_exit_override(<span class="keywordtype">void</span> *v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        lthread_exit(v);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    _sys_pthread_funcs.f_pthread_exit(v);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">*pthread_getspecific(pthread_key_t key)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_getspecific((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) key);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_getspecific(key);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_getcpuclockid(pthread_t a, clockid_t *b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_getcpuclockid(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_join(pthread_t tid, <span class="keywordtype">void</span> **val)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_join((<span class="keyword">struct</span> lthread *)tid, val);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_join(tid, val);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_key_create(pthread_key_t *keyptr, <span class="keywordtype">void</span> (*dtor) (<span class="keywordtype">void</span> *))</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_key_create((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)keyptr, dtor);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_key_create(keyptr, dtor);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_key_delete(pthread_key_t key)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        lthread_key_delete((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) key);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_key_delete(key);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">pthread_mutex_init(pthread_mutex_t *mutex, <span class="keyword">const</span> pthread_mutexattr_t *attr)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_mutex_init(NULL,</div>
<div class="line">                (<span class="keyword">struct</span> lthread_mutex **)mutex,</div>
<div class="line">                (<span class="keyword">const</span> <span class="keyword">struct</span> lthread_mutexattr *)attr);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_mutex_init(mutex, attr);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_mutex_lock(pthread_mutex_t *mutex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_mutex_lock(*(<span class="keyword">struct</span> lthread_mutex **)mutex);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_mutex_lock(mutex);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_mutex_trylock(pthread_mutex_t *mutex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_mutex_trylock(*(<span class="keyword">struct</span> lthread_mutex **)mutex);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_mutex_trylock(mutex);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_mutex_timedlock(pthread_mutex_t *mutex, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_mutex_timedlock(mutex, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_mutex_unlock(pthread_mutex_t *mutex)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> lthread_mutex_unlock(*(<span class="keyword">struct</span> lthread_mutex **)mutex);</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_mutex_unlock(mutex);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_once(pthread_once_t *a, <span class="keywordtype">void</span> (b) (<span class="keywordtype">void</span>))</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_once(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_destroy(pthread_rwlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_destroy(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_init(pthread_rwlock_t *a, <span class="keyword">const</span> pthread_rwlockattr_t *b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_init(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_rdlock(pthread_rwlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_rdlock(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_timedrdlock(pthread_rwlock_t *a, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_timedrdlock(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_timedwrlock(pthread_rwlock_t *a, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_timedwrlock(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_tryrdlock(pthread_rwlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_tryrdlock(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_trywrlock(pthread_rwlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_trywrlock(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_unlock(pthread_rwlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_unlock(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_rwlock_wrlock(pthread_rwlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_rwlock_wrlock(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_yield(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        lthread_yield();</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_yield();</div>
<div class="line"></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">pthread_t pthread_self(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>)</div>
<div class="line">        <span class="keywordflow">return</span> (pthread_t) lthread_current();</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_self();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_setspecific(pthread_key_t key, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        <span class="keywordtype">int</span> rv =  lthread_setspecific((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)key, data);</div>
<div class="line">        <span class="keywordflow">return</span> rv;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_setspecific(key, data);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_spin_init(pthread_spinlock_t *a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_spin_init(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_spin_destroy(pthread_spinlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_spin_destroy(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_spin_lock(pthread_spinlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_spin_lock(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_spin_trylock(pthread_spinlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_spin_trylock(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_spin_unlock(pthread_spinlock_t *a)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_spin_unlock(a);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_cancel(pthread_t tid)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        lthread_cancel(*(<span class="keyword">struct</span> lthread **)tid);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_cancel(tid);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_setcancelstate(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> *b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_setcancelstate(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_setcanceltype(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> *b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_setcanceltype(a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> pthread_testcancel(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_testcancel();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_getschedparam(pthread_t tid, <span class="keywordtype">int</span> *a, <span class="keyword">struct</span> sched_param *b)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_getschedparam(tid, a, b);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pthread_setschedparam(pthread_t a, <span class="keywordtype">int</span> b, <span class="keyword">const</span> <span class="keyword">struct</span> sched_param *c)</div>
<div class="line">{</div>
<div class="line">    NOT_IMPLEMENTED;</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_setschedparam(a, b, c);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> nanosleep(<span class="keyword">const</span> <span class="keyword">struct</span> timespec *req, <span class="keyword">struct</span> timespec *rem)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        uint64_t ns = req-&gt;tv_sec * 1000000000 + req-&gt;tv_nsec;</div>
<div class="line"></div>
<div class="line">        lthread_sleep(ns);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_nanosleep(req, rem);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">pthread_setaffinity_np(pthread_t thread, <span class="keywordtype">size_t</span> cpusetsize,</div>
<div class="line">               <span class="keyword">const</span> cpu_set_t *cpuset)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">override</span>) {</div>
<div class="line">        <span class="comment">/* we only allow affinity with a single CPU */</span></div>
<div class="line">        <span class="keywordflow">if</span> (CPU_COUNT(cpuset) != 1)</div>
<div class="line">            <span class="keywordflow">return</span> POSIX_ERRNO(EINVAL);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* we only allow the current thread to sets its own affinity */</span></div>
<div class="line">        <span class="keyword">struct </span>lthread *lt = (<span class="keyword">struct </span>lthread *)thread;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (lthread_current() != lt)</div>
<div class="line">            <span class="keywordflow">return</span> POSIX_ERRNO(EINVAL);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* determine the CPU being requested */</span></div>
<div class="line">        <span class="keywordtype">int</span> i;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (i = 0; i &lt; LTHREAD_MAX_LCORES; i++) {</div>
<div class="line">            <span class="keywordflow">if</span> (!CPU_ISSET(i, cpuset))</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">/* check requested core is allowed */</span></div>
<div class="line">        <span class="keywordflow">if</span> (i == LTHREAD_MAX_LCORES)</div>
<div class="line">            <span class="keywordflow">return</span> POSIX_ERRNO(EINVAL);</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* finally we can set affinity to the requested lcore */</span></div>
<div class="line">        lthread_set_affinity(i);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> _sys_pthread_funcs.f_pthread_setaffinity_np(thread, cpusetsize,</div>
<div class="line">                               cpuset);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
