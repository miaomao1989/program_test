<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DPDK: lib/librte_kni/rte_kni.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">16.04.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_57fc2e9d988df25248b2986356737354.html">librte_kni</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_kni.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rte__pci_8h_source.html">rte_pci.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>&gt;</code><br/>
<code>#include &lt;exec-env/rte_kni_common.h&gt;</code><br/>
</div>
<p><a href="rte__kni_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__kni__ops.html">rte_kni_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__kni__conf.html">rte_kni_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:add8d82dbb8f3fcec208274cccc6a10d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#add8d82dbb8f3fcec208274cccc6a10d6">rte_kni_init</a> (unsigned int max_kni_ifaces)</td></tr>
<tr class="separator:add8d82dbb8f3fcec208274cccc6a10d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0e3bfe35ac99edbf07dd709d294176"><td class="memItemLeft" align="right" valign="top">struct rte_kni *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#a6f0e3bfe35ac99edbf07dd709d294176">rte_kni_alloc</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *pktmbuf_pool, const struct <a class="el" href="structrte__kni__conf.html">rte_kni_conf</a> *conf, struct <a class="el" href="structrte__kni__ops.html">rte_kni_ops</a> *ops)</td></tr>
<tr class="separator:a6f0e3bfe35ac99edbf07dd709d294176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfabc840e0630bf581eb5583a7d88fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#abbfabc840e0630bf581eb5583a7d88fe">rte_kni_release</a> (struct rte_kni *kni)</td></tr>
<tr class="separator:abbfabc840e0630bf581eb5583a7d88fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd52d6e1e302e3bb87de6d786b3c5cc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#acd52d6e1e302e3bb87de6d786b3c5cc1">rte_kni_handle_request</a> (struct rte_kni *kni)</td></tr>
<tr class="separator:acd52d6e1e302e3bb87de6d786b3c5cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdd727cdc227d005fef22c0189f3dfe"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#a0cdd727cdc227d005fef22c0189f3dfe">rte_kni_rx_burst</a> (struct rte_kni *kni, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **mbufs, unsigned num)</td></tr>
<tr class="separator:a0cdd727cdc227d005fef22c0189f3dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae470743959cbf73648b242d9f7270b02"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#ae470743959cbf73648b242d9f7270b02">rte_kni_tx_burst</a> (struct rte_kni *kni, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **mbufs, unsigned num)</td></tr>
<tr class="separator:ae470743959cbf73648b242d9f7270b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada87cc7b758d69b75c4fadce54b1b0e1"><td class="memItemLeft" align="right" valign="top">struct rte_kni *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#ada87cc7b758d69b75c4fadce54b1b0e1">rte_kni_get</a> (const char *name)</td></tr>
<tr class="separator:ada87cc7b758d69b75c4fadce54b1b0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecae7b93ec018dde146c91a90644a49c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#aecae7b93ec018dde146c91a90644a49c">rte_kni_get_name</a> (const struct rte_kni *kni)</td></tr>
<tr class="separator:aecae7b93ec018dde146c91a90644a49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf39ad15da70f8f024815d40b798bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#aebdf39ad15da70f8f024815d40b798bc">rte_kni_register_handlers</a> (struct rte_kni *kni, struct <a class="el" href="structrte__kni__ops.html">rte_kni_ops</a> *ops)</td></tr>
<tr class="separator:aebdf39ad15da70f8f024815d40b798bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b283ead1a7e357e8b18f1014583e5c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#a4b283ead1a7e357e8b18f1014583e5c4">rte_kni_unregister_handlers</a> (struct rte_kni *kni)</td></tr>
<tr class="separator:a4b283ead1a7e357e8b18f1014583e5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edb3d07e6ae68b6631fe98e88fc27bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__kni_8h.html#a8edb3d07e6ae68b6631fe98e88fc27bc">rte_kni_close</a> (void)</td></tr>
<tr class="separator:a8edb3d07e6ae68b6631fe98e88fc27bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE KNI</p>
<p>The KNI library provides the ability to create and destroy kernel NIC interfaces that may be used by the RTE application to receive/transmit packets from/to Linux kernel net interfaces.</p>
<p>This library provide two APIs to burst receive packets from KNI interfaces, and burst transmit packets to KNI interfaces. </p>

<p>Definition in file <a class="el" href="rte__kni_8h_source.html">rte_kni.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="add8d82dbb8f3fcec208274cccc6a10d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_kni_init </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_kni_ifaces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize and preallocate KNI subsystem</p>
<p>This function is to be executed on the MASTER lcore only, after EAL initialization and before any KNI interface is attempted to be allocated</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_kni_ifaces</td><td>The maximum number of KNI interfaces that can coexist concurrently </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="kni_2main_8c-example.html#a27">kni/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6f0e3bfe35ac99edbf07dd709d294176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_kni* rte_kni_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>pktmbuf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__kni__conf.html">rte_kni_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__kni__ops.html">rte_kni_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate KNI interface according to the port id, mbuf size, mbuf pool, configurations and callbacks for kernel requests.The KNI interface created in the kernel space is the net interface the traditional Linux application talking to.</p>
<p>The rte_kni_alloc shall not be called before <a class="el" href="rte__kni_8h.html#add8d82dbb8f3fcec208274cccc6a10d6">rte_kni_init()</a> has been called. rte_kni_alloc is thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pktmbuf_pool</td><td>The mempool for allocting mbufs for packets. </td></tr>
    <tr><td class="paramname">conf</td><td>The pointer to the configurations of the KNI device. </td></tr>
    <tr><td class="paramname">ops</td><td>The pointer to the callbacks for the KNI kernel requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The pointer to the context of a KNI interface.</li>
<li>NULL indicate error. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="kni_2main_8c-example.html#a45">kni/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abbfabc840e0630bf581eb5583a7d88fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_kni_release </td>
          <td>(</td>
          <td class="paramtype">struct rte_kni *&#160;</td>
          <td class="paramname"><em>kni</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release KNI interface according to the context. It will also release the paired KNI interface in kernel space. All processing on the specific KNI context need to be stopped before calling this interface.</p>
<p>rte_kni_release is thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kni</td><td>The pointer to the context of an existent KNI interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 indicates success.</li>
<li>negative value indicates failure. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="kni_2main_8c-example.html#a46">kni/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acd52d6e1e302e3bb87de6d786b3c5cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_kni_handle_request </td>
          <td>(</td>
          <td class="paramtype">struct rte_kni *&#160;</td>
          <td class="paramname"><em>kni</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It is used to handle the request mbufs sent from kernel space. Then analyzes it and calls the specific actions for the specific requests. Finally constructs the response mbuf and puts it back to the resp_q.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kni</td><td>The pointer to the context of an existent KNI interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0</li>
<li>negative value indicates failure. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="kni_2main_8c-example.html#a15">kni/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0cdd727cdc227d005fef22c0189f3dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rte_kni_rx_burst </td>
          <td>(</td>
          <td class="paramtype">struct rte_kni *&#160;</td>
          <td class="paramname"><em>kni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>mbufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a burst of packets from a KNI interface. The retrieved packets are stored in <a class="el" href="structrte__mbuf.html">rte_mbuf</a> structures whose pointers are supplied in the array of mbufs, and the maximum number is indicated by num. It handles the freeing of the mbufs in the free queue of KNI interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kni</td><td>The KNI interface context. </td></tr>
    <tr><td class="paramname">mbufs</td><td>The array to store the pointers of mbufs. </td></tr>
    <tr><td class="paramname">num</td><td>The maximum number per burst.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual number of packets retrieved. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="kni_2main_8c-example.html#a16">kni/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae470743959cbf73648b242d9f7270b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rte_kni_tx_burst </td>
          <td>(</td>
          <td class="paramtype">struct rte_kni *&#160;</td>
          <td class="paramname"><em>kni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>mbufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a burst of packets to a KNI interface. The packets to be sent out are stored in <a class="el" href="structrte__mbuf.html">rte_mbuf</a> structures whose pointers are supplied in the array of mbufs, and the maximum number is indicated by num. It handles allocating the mbufs for KNI interface alloc queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kni</td><td>The KNI interface context. </td></tr>
    <tr><td class="paramname">mbufs</td><td>The array to store the pointers of mbufs. </td></tr>
    <tr><td class="paramname">num</td><td>The maximum number per burst.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual number of packets sent. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="kni_2main_8c-example.html#a14">kni/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ada87cc7b758d69b75c4fadce54b1b0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_kni* rte_kni_get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the KNI context of its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>pointer to the KNI device name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success: Pointer to KNI interface. On failure: NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="aecae7b93ec018dde146c91a90644a49c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_kni_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct rte_kni *&#160;</td>
          <td class="paramname"><em>kni</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name given to a KNI device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kni</td><td>The KNI instance to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the KNI name </dd></dl>

</div>
</div>
<a class="anchor" id="aebdf39ad15da70f8f024815d40b798bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_kni_register_handlers </td>
          <td>(</td>
          <td class="paramtype">struct rte_kni *&#160;</td>
          <td class="paramname"><em>kni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__kni__ops.html">rte_kni_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register KNI request handling for a specified port,and it can be called by master process or slave process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kni</td><td>pointer to struct rte_kni. </td></tr>
    <tr><td class="paramname">ops</td><td>ponter to struct <a class="el" href="structrte__kni__ops.html">rte_kni_ops</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success: 0 On failure: -1 </dd></dl>

</div>
</div>
<a class="anchor" id="a4b283ead1a7e357e8b18f1014583e5c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_kni_unregister_handlers </td>
          <td>(</td>
          <td class="paramtype">struct rte_kni *&#160;</td>
          <td class="paramname"><em>kni</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister KNI request handling for a specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kni</td><td>pointer to struct rte_kni.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success: 0 On failure: -1 </dd></dl>

</div>
</div>
<a class="anchor" id="a8edb3d07e6ae68b6631fe98e88fc27bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_kni_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close KNI device. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="kni_2main_8c-example.html#a54">kni/main.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
