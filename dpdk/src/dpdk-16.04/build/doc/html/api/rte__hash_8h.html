<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DPDK: lib/librte_hash/rte_hash.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">16.04.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_5e14993b9b1571024c777dcdb495ae81.html">librte_hash</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_hash.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;stddef.h&gt;</code><br/>
</div>
<p><a href="rte__hash_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a080e28e97cdd08dddfee7fc49084c0f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a080e28e97cdd08dddfee7fc49084c0f4">RTE_HASH_ENTRIES_MAX</a>&#160;&#160;&#160;(1 &lt;&lt; 30)</td></tr>
<tr class="separator:a080e28e97cdd08dddfee7fc49084c0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2eca61b3180fccd47b5170fa115d48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a6f2eca61b3180fccd47b5170fa115d48">RTE_HASH_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a6f2eca61b3180fccd47b5170fa115d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d9cbb1b31cf0a18427128378bc94ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a40d9cbb1b31cf0a18427128378bc94ec">RTE_HASH_LOOKUP_BULK_MAX</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a40d9cbb1b31cf0a18427128378bc94ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd61e2408201c3640614d663c26ca832"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#afd61e2408201c3640614d663c26ca832">RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:afd61e2408201c3640614d663c26ca832"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab9cf833d6d86f042b9ac01ae2e5b998f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a></td></tr>
<tr class="separator:ab9cf833d6d86f042b9ac01ae2e5b998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1c929f34ddfa9e3e808742926cafc8"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a3d1c929f34ddfa9e3e808742926cafc8">rte_hash_function</a> )(const void *key, uint32_t key_len, uint32_t init_val)</td></tr>
<tr class="separator:a3d1c929f34ddfa9e3e808742926cafc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f2de78bbd55263577df24c31c2e1be"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a27f2de78bbd55263577df24c31c2e1be">rte_hash_cmp_eq_t</a> )(const void *key1, const void *key2, size_t key_len)</td></tr>
<tr class="separator:a27f2de78bbd55263577df24c31c2e1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5afbd2564f738149a241bc22b2428612"><td class="memItemLeft" align="right" valign="top">struct rte_hash *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a5afbd2564f738149a241bc22b2428612">rte_hash_create</a> (const struct <a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a> *params)</td></tr>
<tr class="separator:a5afbd2564f738149a241bc22b2428612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cf154793d40409002d04f3e6d115d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#ad9cf154793d40409002d04f3e6d115d7">rte_hash_set_cmp_func</a> (struct rte_hash *h, <a class="el" href="rte__hash_8h.html#a27f2de78bbd55263577df24c31c2e1be">rte_hash_cmp_eq_t</a> func)</td></tr>
<tr class="separator:ad9cf154793d40409002d04f3e6d115d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c3876597e47c045c945d78e0e1d332"><td class="memItemLeft" align="right" valign="top">struct rte_hash *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a04c3876597e47c045c945d78e0e1d332">rte_hash_find_existing</a> (const char *name)</td></tr>
<tr class="separator:a04c3876597e47c045c945d78e0e1d332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b82800460ad6918b822db30d1c21f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a2b82800460ad6918b822db30d1c21f77">rte_hash_free</a> (struct rte_hash *h)</td></tr>
<tr class="separator:a2b82800460ad6918b822db30d1c21f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4facc8e4c8a90695d23c8b00e864147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#ae4facc8e4c8a90695d23c8b00e864147">rte_hash_reset</a> (struct rte_hash *h)</td></tr>
<tr class="separator:ae4facc8e4c8a90695d23c8b00e864147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fbd5835f9ed6ff92e052a79f905237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a31fbd5835f9ed6ff92e052a79f905237">rte_hash_add_key_data</a> (const struct rte_hash *h, const void *key, void *data)</td></tr>
<tr class="separator:a31fbd5835f9ed6ff92e052a79f905237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eab0eba6576917e179532b0a768a40"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a35eab0eba6576917e179532b0a768a40">rte_hash_add_key_with_hash_data</a> (const struct rte_hash *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig, void *data)</td></tr>
<tr class="separator:a35eab0eba6576917e179532b0a768a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0247f58baa6cbf614e5b729ff0baf27e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a0247f58baa6cbf614e5b729ff0baf27e">rte_hash_add_key</a> (const struct rte_hash *h, const void *key)</td></tr>
<tr class="separator:a0247f58baa6cbf614e5b729ff0baf27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa426cfe49f1b6750cf35e932bb55067"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aaa426cfe49f1b6750cf35e932bb55067">rte_hash_add_key_with_hash</a> (const struct rte_hash *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:aaa426cfe49f1b6750cf35e932bb55067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa125f9c9f57ea5fdf2752bcb506a058"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aaa125f9c9f57ea5fdf2752bcb506a058">rte_hash_del_key</a> (const struct rte_hash *h, const void *key)</td></tr>
<tr class="separator:aaa125f9c9f57ea5fdf2752bcb506a058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da9abc1a395e6891d5f5d0f2ac69cf7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a0da9abc1a395e6891d5f5d0f2ac69cf7">rte_hash_del_key_with_hash</a> (const struct rte_hash *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:a0da9abc1a395e6891d5f5d0f2ac69cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd8f85b9c99eea0a619acc1d6ce2b2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a1bd8f85b9c99eea0a619acc1d6ce2b2c">rte_hash_lookup_data</a> (const struct rte_hash *h, const void *key, void **data)</td></tr>
<tr class="separator:a1bd8f85b9c99eea0a619acc1d6ce2b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a201074d14a769bbd24888d881d879"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a61a201074d14a769bbd24888d881d879">rte_hash_lookup_with_hash_data</a> (const struct rte_hash *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig, void **data)</td></tr>
<tr class="separator:a61a201074d14a769bbd24888d881d879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ff0b837d39bbff00863feabf15e224"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a62ff0b837d39bbff00863feabf15e224">rte_hash_lookup</a> (const struct rte_hash *h, const void *key)</td></tr>
<tr class="separator:a62ff0b837d39bbff00863feabf15e224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf0a56da3a957a113ea1bfedd78c7e6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a8bf0a56da3a957a113ea1bfedd78c7e6">rte_hash_lookup_with_hash</a> (const struct rte_hash *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:a8bf0a56da3a957a113ea1bfedd78c7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade102f06405468de55ba865e139ad9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aade102f06405468de55ba865e139ad9f">rte_hash_hash</a> (const struct rte_hash *h, const void *key)</td></tr>
<tr class="separator:aade102f06405468de55ba865e139ad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf63604a14912474cdb00ca3c014cd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#afbf63604a14912474cdb00ca3c014cd1">rte_hash_lookup_bulk_data</a> (const struct rte_hash *h, const void **keys, uint32_t num_keys, uint64_t *hit_mask, void *data[])</td></tr>
<tr class="separator:afbf63604a14912474cdb00ca3c014cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420dedbd249c73bbb94a98e10a87b088"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a420dedbd249c73bbb94a98e10a87b088">rte_hash_lookup_bulk</a> (const struct rte_hash *h, const void **keys, uint32_t num_keys, int32_t *positions)</td></tr>
<tr class="separator:a420dedbd249c73bbb94a98e10a87b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422544187ab0adad6f12e339bfb2b83f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a422544187ab0adad6f12e339bfb2b83f">rte_hash_iterate</a> (const struct rte_hash *h, const void **key, void **data, uint32_t *next)</td></tr>
<tr class="separator:a422544187ab0adad6f12e339bfb2b83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Hash Table </p>

<p>Definition in file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a080e28e97cdd08dddfee7fc49084c0f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_ENTRIES_MAX&#160;&#160;&#160;(1 &lt;&lt; 30)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum size of hash table that can be created. </p>

<p>Definition at line <a class="el" href="rte__hash_8h_source.html#l00051">51</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6f2eca61b3180fccd47b5170fa115d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of characters in hash name. </p>

<p>Definition at line <a class="el" href="rte__hash_8h_source.html#l00054">54</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a class="anchor" id="a40d9cbb1b31cf0a18427128378bc94ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_LOOKUP_BULK_MAX&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of keys that can be searched for using rte_hash_lookup_bulk. </p>

<p>Definition at line <a class="el" href="rte__hash_8h_source.html#l00057">57</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a class="anchor" id="afd61e2408201c3640614d663c26ca832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable Hardware transactional memory support. </p>

<p>Definition at line <a class="el" href="rte__hash_8h_source.html#l00061">61</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab9cf833d6d86f042b9ac01ae2e5b998f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signature of key that is stored internally. </p>

<p>Definition at line <a class="el" href="rte__hash_8h_source.html#l00064">64</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d1c929f34ddfa9e3e808742926cafc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* rte_hash_function)(const void *key, uint32_t key_len, uint32_t init_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function that can be used for calculating the hash value. </p>

<p>Definition at line <a class="el" href="rte__hash_8h_source.html#l00067">67</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27f2de78bbd55263577df24c31c2e1be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_hash_cmp_eq_t)(const void *key1, const void *key2, size_t key_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function used to compare the hash key. </p>

<p>Definition at line <a class="el" href="rte__hash_8h_source.html#l00071">71</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5afbd2564f738149a241bc22b2428612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_hash* rte_hash_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Parameters used to create and initialise the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to hash table structure that is used in future hash table operations, or NULL on error, with error code set in rte_errno. Possible rte_errno errors include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to <a class="el" href="structrte__config.html">rte_config</a> structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>ENOENT - missing entry</li>
<li>EINVAL - invalid parameter passed to function</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="l3fwd-power_2main_8c-example.html#a85">l3fwd-power/main.c</a>, <a class="el" href="l3fwd-vf_2main_8c-example.html#a61">l3fwd-vf/main.c</a>, and <a class="el" href="performance-thread_2l3fwd-thread_2main_8c-example.html#a78">performance-thread/l3fwd-thread/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad9cf154793d40409002d04f3e6d115d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_hash_set_cmp_func </td>
          <td>(</td>
          <td class="paramtype">struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#a27f2de78bbd55263577df24c31c2e1be">rte_hash_cmp_eq_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a new hash compare function other than the default one.</p>
<dl class="section note"><dt>Note</dt><dd>Function pointer does not work with multi-process, so do not use it in multi-process mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table for which the function is to be changed </td></tr>
    <tr><td class="paramname">func</td><td>New compare function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04c3876597e47c045c945d78e0e1d332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_hash* rte_hash_find_existing </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an existing hash table object and return a pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the hash table as passed to <a class="el" href="rte__hash_8h.html#a5afbd2564f738149a241bc22b2428612">rte_hash_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to hash table or NULL if object not found with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - value not available for return </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2b82800460ad6918b822db30d1c21f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_hash_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-allocate all memory used by hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4facc8e4c8a90695d23c8b00e864147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_hash_reset </td>
          <td>(</td>
          <td class="paramtype">struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all hash structure, by zeroing all entries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31fbd5835f9ed6ff92e052a79f905237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_add_key_data </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key-value pair to an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
    <tr><td class="paramname">data</td><td>Data to add to the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if added successfully</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a35eab0eba6576917e179532b0a768a40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_add_key_with_hash_data </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key-value pair with a pre-computed hash value to an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key' </td></tr>
    <tr><td class="paramname">data</td><td>Data to add to the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if added successfully</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0247f58baa6cbf614e5b729ff0baf27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_add_key </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key to an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="l3fwd-power_2main_8c-example.html#a86">l3fwd-power/main.c</a>, <a class="el" href="l3fwd-vf_2main_8c-example.html#a62">l3fwd-vf/main.c</a>, and <a class="el" href="performance-thread_2l3fwd-thread_2main_8c-example.html#a74">performance-thread/l3fwd-thread/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aaa426cfe49f1b6750cf35e932bb55067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_add_key_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key to an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aaa125f9c9f57ea5fdf2752bcb506a058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_del_key </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a key from an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to remove the key from. </td></tr>
    <tr><td class="paramname">key</td><td>Key to remove from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0da9abc1a395e6891d5f5d0f2ac69cf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_del_key_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a key from an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to remove the key from. </td></tr>
    <tr><td class="paramname">key</td><td>Key to remove from the hash table. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1bd8f85b9c99eea0a619acc1d6ce2b2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_data </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key-value pair in the hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
    <tr><td class="paramname">data</td><td>Output with pointer to data returned from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful lookup<ul>
<li>EINVAL if the parameters are invalid.</li>
<li>ENOENT if the key is not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a61a201074d14a769bbd24888d881d879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_with_hash_data </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key-value pair with a pre-computed hash value to an existing hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key' </td></tr>
    <tr><td class="paramname">data</td><td>Output with pointer to data returned from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful lookup<ul>
<li>EINVAL if the parameters are invalid.</li>
<li>ENOENT if the key is not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a62ff0b837d39bbff00863feabf15e224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key in the hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="l3fwd-power_2main_8c-example.html#a39">l3fwd-power/main.c</a>, <a class="el" href="l3fwd-vf_2main_8c-example.html#a37">l3fwd-vf/main.c</a>, and <a class="el" href="performance-thread_2l3fwd-thread_2main_8c-example.html#a30">performance-thread/l3fwd-thread/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8bf0a56da3a957a113ea1bfedd78c7e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_lookup_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key in the hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
    <tr><td class="paramname">sig</td><td>Hash value to remove from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aade102f06405468de55ba865e139ad9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> rte_hash_hash </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calc a hash value by key. This operation is not multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>hash value </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afbf63604a14912474cdb00ca3c014cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_bulk_data </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>hit_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find multiple keys in the hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">keys</td><td>A pointer to a list of keys to look for. </td></tr>
    <tr><td class="paramname">num_keys</td><td>How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX). </td></tr>
    <tr><td class="paramname">hit_mask</td><td>Output containing a bitmask with all successful lookups. </td></tr>
    <tr><td class="paramname">data</td><td>Output containing array of data returned from all the successful lookups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if there's an error, otherwise number of successful lookups. </dd></dl>

</div>
</div>
<a class="anchor" id="a420dedbd249c73bbb94a98e10a87b088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_bulk </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find multiple keys in the hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">keys</td><td>A pointer to a list of keys to look for. </td></tr>
    <tr><td class="paramname">num_keys</td><td>How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX). </td></tr>
    <tr><td class="paramname">positions</td><td>Output containing a list of values, corresponding to the list of keys that can be used by the caller as an offset into an array of user data. These values are unique for each key, and are the same values that were returned when each key was added. If a key in the list was not found, then -ENOENT will be the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if there's an error, otherwise 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a422544187ab0adad6f12e339bfb2b83f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_iterate </td>
          <td>(</td>
          <td class="paramtype">const struct rte_hash *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate through the hash table, returning key-value pairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to iterate </td></tr>
    <tr><td class="paramname">key</td><td>Output containing the key where current iterator was pointing at </td></tr>
    <tr><td class="paramname">data</td><td>Output containing the data associated with key. Returns NULL if data was not stored. </td></tr>
    <tr><td class="paramname">next</td><td>Pointer to iterator. Should be 0 to start iterating the hash table. Iterator is incremented after each call of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position where key was stored, if successful.<ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if end of the hash table. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
