<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DPDK: lib/librte_mempool/rte_mempool.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">16.04.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_ede7e24c7966ae13eacb9e9d5c8994f5.html">librte_mempool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_mempool.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;errno.h&gt;</code><br/>
<code>#include &lt;inttypes.h&gt;</code><br/>
<code>#include &lt;sys/queue.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__log_8h_source.html">rte_log.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__debug_8h_source.html">rte_debug.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__lcore_8h_source.html">rte_lcore.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__branch__prediction_8h_source.html">rte_branch_prediction.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>&gt;</code><br/>
</div>
<p><a href="rte__mempool_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__objsz.html">rte_mempool_objsz</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__objhdr.html">rte_mempool_objhdr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__objtlr.html">rte_mempool_objtlr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool.html">rte_mempool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ace39cb6a7415a12e81e534c084eaffae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ace39cb6a7415a12e81e534c084eaffae">RTE_MEMPOOL_HEADER_COOKIE1</a>&#160;&#160;&#160;0xbadbadbadadd2e55ULL</td></tr>
<tr class="separator:ace39cb6a7415a12e81e534c084eaffae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734531a6320af1bd65287929672b5dd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a734531a6320af1bd65287929672b5dd7">RTE_MEMPOOL_HEADER_COOKIE2</a>&#160;&#160;&#160;0xf2eef2eedadd2e55ULL</td></tr>
<tr class="separator:a734531a6320af1bd65287929672b5dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6419c9ccd761d970b756c37e25d72dd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6419c9ccd761d970b756c37e25d72dd7">RTE_MEMPOOL_TRAILER_COOKIE</a>&#160;&#160;&#160;0xadd2e55badbadbadULL</td></tr>
<tr class="separator:a6419c9ccd761d970b756c37e25d72dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e5aa92b19f0f8d981b7016264456d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#af6e5aa92b19f0f8d981b7016264456d7">RTE_MEMPOOL_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:af6e5aa92b19f0f8d981b7016264456d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0648fad3d8d844ccf917cbebe9f741"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a2f0648fad3d8d844ccf917cbebe9f741">MEMPOOL_PG_NUM_DEFAULT</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a2f0648fad3d8d844ccf917cbebe9f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2274675362f7964be2bc499e55782eb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a2274675362f7964be2bc499e55782eb5">MEMPOOL_F_NO_SPREAD</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a2274675362f7964be2bc499e55782eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b50b6c6c3a097d768c8337d146caa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a7f4b50b6c6c3a097d768c8337d146caa">MEMPOOL_F_NO_CACHE_ALIGN</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a7f4b50b6c6c3a097d768c8337d146caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee48ca768ddf8494f6618ca54e2e84e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aee48ca768ddf8494f6618ca54e2e84e9">MEMPOOL_F_SP_PUT</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:aee48ca768ddf8494f6618ca54e2e84e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08a019547fb3968e73aab0dafefc069"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ab08a019547fb3968e73aab0dafefc069">MEMPOOL_F_SC_GET</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:ab08a019547fb3968e73aab0dafefc069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3570153f46e8b03b81cb854f609d8fca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a3570153f46e8b03b81cb854f609d8fca">MEMPOOL_HEADER_SIZE</a>(<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, pgn)</td></tr>
<tr class="separator:a3570153f46e8b03b81cb854f609d8fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35f443eaacec8c4f305eac54c5e01a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#af35f443eaacec8c4f305eac54c5e01a2">MEMPOOL_IS_CONTIG</a>(<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)</td></tr>
<tr class="separator:af35f443eaacec8c4f305eac54c5e01a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a01ac25c657117b83fcd8922e66623bec"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a01ac25c657117b83fcd8922e66623bec">rte_mempool_obj_iter_t</a> )(void *, void *, void *, uint32_t)</td></tr>
<tr class="separator:a01ac25c657117b83fcd8922e66623bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5c4b0e7f6f6eb0985aed01f745b627"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6f5c4b0e7f6f6eb0985aed01f745b627">rte_mempool_obj_ctor_t</a> )(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *, void *, unsigned)</td></tr>
<tr class="separator:a6f5c4b0e7f6f6eb0985aed01f745b627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429d1d3d79259022df36fc2b5f7db003"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a429d1d3d79259022df36fc2b5f7db003">rte_mempool_ctor_t</a> )(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *)</td></tr>
<tr class="separator:a429d1d3d79259022df36fc2b5f7db003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b1ffc62a2fcc1ac728158ad2b177d0a"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a9b1ffc62a2fcc1ac728158ad2b177d0a">rte_mempool_from_obj</a> (void *obj)</td></tr>
<tr class="separator:a9b1ffc62a2fcc1ac728158ad2b177d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc1b419777b2691f7a1b2757a1f1205"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a9dc1b419777b2691f7a1b2757a1f1205">rte_mempool_obj_iter</a> (void *vaddr, uint32_t elt_num, size_t elt_sz, size_t align, const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a> paddr[], uint32_t pg_num, uint32_t pg_shift, <a class="el" href="rte__mempool_8h.html#a01ac25c657117b83fcd8922e66623bec">rte_mempool_obj_iter_t</a> obj_iter, void *obj_iter_arg)</td></tr>
<tr class="separator:a9dc1b419777b2691f7a1b2757a1f1205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1d01a45144e3203c36d1800cb8f17"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create</a> (const char *name, unsigned n, unsigned elt_size, unsigned cache_size, unsigned private_data_size, <a class="el" href="rte__mempool_8h.html#a429d1d3d79259022df36fc2b5f7db003">rte_mempool_ctor_t</a> *mp_init, void *mp_init_arg, <a class="el" href="rte__mempool_8h.html#a6f5c4b0e7f6f6eb0985aed01f745b627">rte_mempool_obj_ctor_t</a> *obj_init, void *obj_init_arg, int socket_id, unsigned flags)</td></tr>
<tr class="separator:a7dc1d01a45144e3203c36d1800cb8f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1921c0e704757b024cb79604db40f4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a5c1921c0e704757b024cb79604db40f4">rte_mempool_xmem_create</a> (const char *name, unsigned n, unsigned elt_size, unsigned cache_size, unsigned private_data_size, <a class="el" href="rte__mempool_8h.html#a429d1d3d79259022df36fc2b5f7db003">rte_mempool_ctor_t</a> *mp_init, void *mp_init_arg, <a class="el" href="rte__mempool_8h.html#a6f5c4b0e7f6f6eb0985aed01f745b627">rte_mempool_obj_ctor_t</a> *obj_init, void *obj_init_arg, int socket_id, unsigned flags, void *vaddr, const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a> paddr[], uint32_t pg_num, uint32_t pg_shift)</td></tr>
<tr class="separator:a5c1921c0e704757b024cb79604db40f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad6189423d5eefaa551c4fb5bf24ecf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a9ad6189423d5eefaa551c4fb5bf24ecf">rte_dom0_mempool_create</a> (const char *name, unsigned n, unsigned elt_size, unsigned cache_size, unsigned private_data_size, <a class="el" href="rte__mempool_8h.html#a429d1d3d79259022df36fc2b5f7db003">rte_mempool_ctor_t</a> *mp_init, void *mp_init_arg, <a class="el" href="rte__mempool_8h.html#a6f5c4b0e7f6f6eb0985aed01f745b627">rte_mempool_obj_ctor_t</a> *obj_init, void *obj_init_arg, int socket_id, unsigned flags)</td></tr>
<tr class="separator:a9ad6189423d5eefaa551c4fb5bf24ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cea3286380dbf5ee641efd8d6c442b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a97cea3286380dbf5ee641efd8d6c442b">rte_mempool_dump</a> (FILE *f, const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)</td></tr>
<tr class="separator:a97cea3286380dbf5ee641efd8d6c442b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305999d4289856a541855ca22dce91ea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a305999d4289856a541855ca22dce91ea">rte_mempool_mp_put_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a305999d4289856a541855ca22dce91ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e0ad89db728923a7f84e56633346e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a13e0ad89db728923a7f84e56633346e6">rte_mempool_sp_put_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a13e0ad89db728923a7f84e56633346e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46972d2b6e77edd375231453667ce46b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a46972d2b6e77edd375231453667ce46b">rte_mempool_put_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a46972d2b6e77edd375231453667ce46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad267e5cb87337aa1fa83b72ead46f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a13ad267e5cb87337aa1fa83b72ead46f">rte_mempool_mp_put</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void *obj)</td></tr>
<tr class="separator:a13ad267e5cb87337aa1fa83b72ead46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15870119eb7b2816112d44c0fd98b585"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a15870119eb7b2816112d44c0fd98b585">rte_mempool_sp_put</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void *obj)</td></tr>
<tr class="separator:a15870119eb7b2816112d44c0fd98b585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def6fc59b18be5c983c05de0df5f918"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void *obj)</td></tr>
<tr class="separator:a3def6fc59b18be5c983c05de0df5f918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05723e7135fedf8ba6756af8be71e1ca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a05723e7135fedf8ba6756af8be71e1ca">rte_mempool_mc_get_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a05723e7135fedf8ba6756af8be71e1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6393ce89533dae2212de148aab30dd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a4d6393ce89533dae2212de148aab30dd">rte_mempool_sc_get_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a4d6393ce89533dae2212de148aab30dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a6b5afb4ed66c57c375e7d794e7781"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a51a6b5afb4ed66c57c375e7d794e7781">rte_mempool_get_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a51a6b5afb4ed66c57c375e7d794e7781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369fa1b1e5d9664c85e94ef58a463b82"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a369fa1b1e5d9664c85e94ef58a463b82">rte_mempool_mc_get</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void **obj_p)</td></tr>
<tr class="separator:a369fa1b1e5d9664c85e94ef58a463b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47538ab596fd4b69e151f8a8962da8a1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a47538ab596fd4b69e151f8a8962da8a1">rte_mempool_sc_get</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void **obj_p)</td></tr>
<tr class="separator:a47538ab596fd4b69e151f8a8962da8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bffea924acb47a9ec321abb21ea0c5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ad1bffea924acb47a9ec321abb21ea0c5">rte_mempool_get</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, void **obj_p)</td></tr>
<tr class="separator:ad1bffea924acb47a9ec321abb21ea0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1c868324f15c80e1956ee87249704b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a4e1c868324f15c80e1956ee87249704b">rte_mempool_count</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)</td></tr>
<tr class="separator:a4e1c868324f15c80e1956ee87249704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80976616504e426555f8eda95050b998"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a80976616504e426555f8eda95050b998">rte_mempool_free_count</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)</td></tr>
<tr class="separator:a80976616504e426555f8eda95050b998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a83e5cc7f9d57f154839b1c80992a3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a85a83e5cc7f9d57f154839b1c80992a3">rte_mempool_full</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)</td></tr>
<tr class="separator:a85a83e5cc7f9d57f154839b1c80992a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ad83873c9af9bc2012153cd4b4ed52"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ad6ad83873c9af9bc2012153cd4b4ed52">rte_mempool_empty</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)</td></tr>
<tr class="separator:ad6ad83873c9af9bc2012153cd4b4ed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8285cccb4078582d361b505891bd0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a8c8285cccb4078582d361b505891bd0a">rte_mempool_virt2phy</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, const void *elt)</td></tr>
<tr class="separator:a8c8285cccb4078582d361b505891bd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b29b84fb7ca24d252abab5f830daa7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a1b29b84fb7ca24d252abab5f830daa7b">rte_mempool_audit</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)</td></tr>
<tr class="separator:a1b29b84fb7ca24d252abab5f830daa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b794c0cd2a78c74817b250becf981fc"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6b794c0cd2a78c74817b250becf981fc">rte_mempool_get_priv</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *<a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)</td></tr>
<tr class="separator:a6b794c0cd2a78c74817b250becf981fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1120319a35b0cf0b23827705b2229a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#acb1120319a35b0cf0b23827705b2229a">rte_mempool_list_dump</a> (FILE *f)</td></tr>
<tr class="separator:acb1120319a35b0cf0b23827705b2229a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5887135fc6329a35780b0053e769ad"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a3a5887135fc6329a35780b0053e769ad">rte_mempool_lookup</a> (const char *name)</td></tr>
<tr class="separator:a3a5887135fc6329a35780b0053e769ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121d699436738109067ed80a1ecae38f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a121d699436738109067ed80a1ecae38f">rte_mempool_calc_obj_size</a> (uint32_t elt_size, uint32_t flags, struct <a class="el" href="structrte__mempool__objsz.html">rte_mempool_objsz</a> *sz)</td></tr>
<tr class="separator:a121d699436738109067ed80a1ecae38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f017f9b78ab1bc71abd21d0bf233e8f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a1f017f9b78ab1bc71abd21d0bf233e8f">rte_mempool_xmem_size</a> (uint32_t elt_num, size_t elt_sz, uint32_t pg_shift)</td></tr>
<tr class="separator:a1f017f9b78ab1bc71abd21d0bf233e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf5dd195fbbb5e0d3b35212bfef534c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a7bf5dd195fbbb5e0d3b35212bfef534c">rte_mempool_xmem_usage</a> (void *vaddr, uint32_t elt_num, size_t elt_sz, const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a> paddr[], uint32_t pg_num, uint32_t pg_shift)</td></tr>
<tr class="separator:a7bf5dd195fbbb5e0d3b35212bfef534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac813bddbff225d65d111dda5a1974b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ac813bddbff225d65d111dda5a1974b3f">rte_mempool_walk</a> (void(*func)(const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *arg), void *arg)</td></tr>
<tr class="separator:ac813bddbff225d65d111dda5a1974b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Mempool.</p>
<p>A memory pool is an allocator of fixed-size object. It is identified by its name, and uses a ring to store free objects. It provides some other optional services, like a per-core object cache, and an alignment helper to ensure that objects are padded to spread them equally on all RAM channels, ranks, and so on.</p>
<p>Objects owned by a mempool should never be added in another mempool. When an object is freed using <a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put()</a> or equivalent, the object data is not modified; the user can save some meta-data in the object data and retrieve them when allocating a new object.</p>
<p>Note: the mempool implementation is not preemptable. A lcore must not be interrupted by another task that uses the same mempool (because it uses a ring which is not preemptable). Also, mempool functions must not be used outside the DPDK environment: for example, in linuxapp environment, a thread that is not created by the EAL must not use mempools. This is due to the per-lcore cache that won't work as <a class="el" href="rte__lcore_8h.html#adfb2b334e7e73f534f25e8888a8a775f">rte_lcore_id()</a> will not return a correct value. </p>

<p>Definition in file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ace39cb6a7415a12e81e534c084eaffae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_HEADER_COOKIE1&#160;&#160;&#160;0xbadbadbadadd2e55ULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header cookie. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00080">80</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a734531a6320af1bd65287929672b5dd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_HEADER_COOKIE2&#160;&#160;&#160;0xf2eef2eedadd2e55ULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header cookie. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00081">81</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6419c9ccd761d970b756c37e25d72dd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_TRAILER_COOKIE&#160;&#160;&#160;0xadd2e55badbadbadULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trailer cookie. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00082">82</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="af6e5aa92b19f0f8d981b7016264456d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum length of a memory pool. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_reassembly_2main_8c-example.html#a57">ip_reassembly/main.c</a>, <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a28">multi_process/l2fwd_fork/main.c</a>, and <a class="el" href="vhost_2main_8c-example.html#a143">vhost/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00123">123</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f0648fad3d8d844ccf917cbebe9f741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_PG_NUM_DEFAULT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mempool over one chunk of physically continuous memory </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00143">143</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2274675362f7964be2bc499e55782eb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_NO_SPREAD&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not spread in memory. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00222">222</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f4b50b6c6c3a097d768c8337d146caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_NO_CACHE_ALIGN&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not align objs on cache lines. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00223">223</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee48ca768ddf8494f6618ca54e2e84e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_SP_PUT&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default put is "single-producer". </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_reassembly_2main_8c-example.html#a65">ip_reassembly/main.c</a>, and <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a58">multi_process/l2fwd_fork/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00224">224</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab08a019547fb3968e73aab0dafefc069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_SC_GET&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default get is "single-consumer". </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_reassembly_2main_8c-example.html#a66">ip_reassembly/main.c</a>, and <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a59">multi_process/l2fwd_fork/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00225">225</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3570153f46e8b03b81cb854f609d8fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_HEADER_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pgn&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<span class="keyword">sizeof</span>(*(<a class="code" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)) + <a class="code" href="rte__common_8h.html#a856650153655096752b4c2a29690a15d">\</a></div>
<div class="line"><a class="code" href="rte__common_8h.html#a856650153655096752b4c2a29690a15d">	RTE_ALIGN_CEIL</a>(((pgn) - <a class="code" href="rte__common_8h.html#ac963da91b35efa4700b73a1f4eb1d8a6">RTE_DIM</a>((<a class="code" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)-&gt;elt_pa)) * \</div>
<div class="line">    <span class="keyword">sizeof</span> ((<a class="code" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)-&gt;elt_pa[0]), RTE_CACHE_LINE_SIZE))</div>
<div class="ttc" id="rte__common_8h_html_a856650153655096752b4c2a29690a15d"><div class="ttname"><a href="rte__common_8h.html#a856650153655096752b4c2a29690a15d">RTE_ALIGN_CEIL</a></div><div class="ttdeci">#define RTE_ALIGN_CEIL(val, align)</div><div class="ttdef"><b>Definition:</b> <a href="rte__common_8h_source.html#l00153">rte_common.h:153</a></div></div>
<div class="ttc" id="rte__common_8h_html_ac963da91b35efa4700b73a1f4eb1d8a6"><div class="ttname"><a href="rte__common_8h.html#ac963da91b35efa4700b73a1f4eb1d8a6">RTE_DIM</a></div><div class="ttdeci">#define RTE_DIM(a)</div><div class="ttdef"><b>Definition:</b> <a href="rte__common_8h_source.html#l00334">rte_common.h:334</a></div></div>
<div class="ttc" id="rte__cryptodev_8h_html_a9f6b27bed19dd1bf3cff6af57d7cf86f"><div class="ttname"><a href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a></div><div class="ttdeci">struct rte_mempool * mp</div><div class="ttdef"><b>Definition:</b> <a href="rte__cryptodev_8h_source.html#l00744">rte_cryptodev.h:744</a></div></div>
</div><!-- fragment --><p>Calculate the size of the mempool header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Pointer to the memory pool. </td></tr>
    <tr><td class="paramname">pgn</td><td>Number of pages used to store mempool objects. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00257">257</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="af35f443eaacec8c4f305eac54c5e01a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_IS_CONTIG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)-&gt;pg_num == <a class="code" href="rte__mempool_8h.html#a2f0648fad3d8d844ccf917cbebe9f741">MEMPOOL_PG_NUM_DEFAULT</a> &amp;&amp; \</div>
<div class="line">    (<a class="code" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)-&gt;phys_addr == (<a class="code" href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a>)-&gt;elt_pa[0])</div>
<div class="ttc" id="rte__mempool_8h_html_a2f0648fad3d8d844ccf917cbebe9f741"><div class="ttname"><a href="rte__mempool_8h.html#a2f0648fad3d8d844ccf917cbebe9f741">MEMPOOL_PG_NUM_DEFAULT</a></div><div class="ttdeci">#define MEMPOOL_PG_NUM_DEFAULT</div><div class="ttdef"><b>Definition:</b> <a href="rte__mempool_8h_source.html#l00143">rte_mempool.h:143</a></div></div>
<div class="ttc" id="rte__cryptodev_8h_html_a9f6b27bed19dd1bf3cff6af57d7cf86f"><div class="ttname"><a href="rte__cryptodev_8h.html#a9f6b27bed19dd1bf3cff6af57d7cf86f">mp</a></div><div class="ttdeci">struct rte_mempool * mp</div><div class="ttdef"><b>Definition:</b> <a href="rte__cryptodev_8h_source.html#l00744">rte_cryptodev.h:744</a></div></div>
</div><!-- fragment --><p>Return true if the whole mempool is in contiguous memory. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00264">264</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a01ac25c657117b83fcd8922e66623bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_mempool_obj_iter_t)(void *, void *, void *, uint32_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A mempool object iterator callback function. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00391">391</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6f5c4b0e7f6f6eb0985aed01f745b627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( rte_mempool_obj_ctor_t)(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *, void *, unsigned)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An object constructor callback function for mempool.</p>
<p>Arguments are the mempool, the opaque pointer given by the user in <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a>, the pointer to the element and the index of the element in the pool. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00443">443</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a429d1d3d79259022df36fc2b5f7db003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( rte_mempool_ctor_t)(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A mempool constructor callback function.</p>
<p>Arguments are the mempool and the opaque pointer given by the user in <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a>. </p>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00452">452</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9b1ffc62a2fcc1ac728158ad2b177d0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_from_obj </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the mempool owning this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An object that is owned by a pool. If this is not the case, the behavior is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the mempool structure. </dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00283">283</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9dc1b419777b2691f7a1b2757a1f1205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rte_mempool_obj_iter </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elt_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a>&#160;</td>
          <td class="paramname"><em>paddr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a01ac25c657117b83fcd8922e66623bec">rte_mempool_obj_iter_t</a>&#160;</td>
          <td class="paramname"><em>obj_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_iter_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call a function for each mempool object in a memory chunk</p>
<p>Iterate across objects of the given size and alignment in the provided chunk of memory. The given memory buffer can consist of disjointed physical pages.</p>
<p>For each object, call the provided callback (if any). This function is used to populate a mempool, or walk through all the elements of a mempool, or estimate how many elements of the given size could be created in the given memory buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address of the memory buffer. </td></tr>
    <tr><td class="paramname">elt_num</td><td>Maximum number of objects to iterate through. </td></tr>
    <tr><td class="paramname">elt_sz</td><td>Size of each object. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment of each object. </td></tr>
    <tr><td class="paramname">paddr</td><td>Array of physical addresses of the pages that comprises given memory buffer. </td></tr>
    <tr><td class="paramname">pg_num</td><td>Number of elements in the paddr array. </td></tr>
    <tr><td class="paramname">pg_shift</td><td>LOG2 of the physical pages size. </td></tr>
    <tr><td class="paramname">obj_iter</td><td>Object iterator callback function (could be NULL). </td></tr>
    <tr><td class="paramname">obj_iter_arg</td><td>User defined parameter for the object iterator callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of objects iterated through. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dc1d01a45144e3203c36d1800cb8f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>private_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a429d1d3d79259022df36fc2b5f7db003">rte_mempool_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>mp_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mp_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a6f5c4b0e7f6f6eb0985aed01f745b627">rte_mempool_obj_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>obj_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new mempool named <em>name</em> in memory.</p>
<p>This function uses <code>memzone_reserve()</code> to allocate memory. The pool contains n elements of elt_size. Its size is set to n. All elements of the mempool are allocated together with the mempool header, in one physically continuous chunk of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mempool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">cache_size</td><td>If cache_size is non-zero, the <a class="el" href="structrte__mempool.html">rte_mempool</a> library will try to limit the accesses to the common lockless pool, by maintaining a per-lcore object cache. This argument must be lower or equal to CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose cache_size to have "n modulo cache_size == 0": if this is not the case, some elements will always stay in the pool and will never be used. The access to the per-lcore table is of course faster than the multi-producer/consumer pool. The cache can be disabled if the cache_size argument is set to 0; it can be useful to avoid losing objects in cache. Note that even if not used, the memory space for cache is always reserved in a mempool structure, except if CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE is set to 0. </td></tr>
    <tr><td class="paramname">private_data_size</td><td>The size of the private data appended after the mempool structure. This is useful for storing some private data after the mempool structure, as is done for rte_mbuf_pool for example. </td></tr>
    <tr><td class="paramname">mp_init</td><td>A function pointer that is called for initialization of the pool, before object initialization. The user can initialize the private data in this function if needed. This parameter can be NULL if not needed. </td></tr>
    <tr><td class="paramname">mp_init_arg</td><td>An opaque pointer to data that can be used in the mempool constructor function. </td></tr>
    <tr><td class="paramname">obj_init</td><td>A function pointer that is called for each object at initialization of the pool. The user can set some meta data in objects if needed. This parameter can be NULL if not needed. The obj_init() function takes the mempool pointer, the init_arg, the object pointer and the object number as parameters. </td></tr>
    <tr><td class="paramname">obj_init_arg</td><td>An opaque pointer to data that can be used as an argument for each call to the object constructor function. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in the case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>The <em>flags</em> arguments is an OR of following flags:<ul>
<li>MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread between channels in RAM: the pool allocator will add padding between objects depending on the hardware configuration. See Memory alignment constraints for details. If this flag is set, the allocator will just align them to a cache line.</li>
<li>MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are cache-aligned. This flag removes this constraint, and no padding will be present between objects. This flag implies MEMPOOL_F_NO_SPREAD.</li>
<li>MEMPOOL_F_SP_PUT: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put()</a> or <a class="el" href="rte__mempool_8h.html#a46972d2b6e77edd375231453667ce46b">rte_mempool_put_bulk()</a> is "single-producer". Otherwise, it is "multi-producers".</li>
<li>MEMPOOL_F_SC_GET: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#ad1bffea924acb47a9ec321abb21ea0c5">rte_mempool_get()</a> or <a class="el" href="rte__mempool_8h.html#a51a6b5afb4ed66c57c375e7d794e7781">rte_mempool_get_bulk()</a> is "single-consumer". Otherwise, it is "multi-consumers". </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to <a class="el" href="structrte__config.html">rte_config</a> structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - cache size provided is too large</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ip_pipeline_2init_8c-example.html#a2">ip_pipeline/init.c</a>, <a class="el" href="ip_reassembly_2main_8c-example.html#a61">ip_reassembly/main.c</a>, <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a60">multi_process/l2fwd_fork/main.c</a>, <a class="el" href="multi_process_2simple_mp_2main_8c-example.html#a11">multi_process/simple_mp/main.c</a>, and <a class="el" href="tep_termination_2main_8c-example.html#a33">tep_termination/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5c1921c0e704757b024cb79604db40f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_xmem_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>private_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a429d1d3d79259022df36fc2b5f7db003">rte_mempool_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>mp_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mp_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a6f5c4b0e7f6f6eb0985aed01f745b627">rte_mempool_obj_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>obj_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a>&#160;</td>
          <td class="paramname"><em>paddr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new mempool named <em>name</em> in memory.</p>
<p>This function uses <code>memzone_reserve()</code> to allocate memory. The pool contains n elements of elt_size. Its size is set to n. Depending on the input parameters, mempool elements can be either allocated together with the mempool header, or an externally provided memory buffer could be used to store mempool objects. In later case, that external memory buffer can consist of set of disjoint physical pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mempool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">cache_size</td><td>If cache_size is non-zero, the <a class="el" href="structrte__mempool.html">rte_mempool</a> library will try to limit the accesses to the common lockless pool, by maintaining a per-lcore object cache. This argument must be lower or equal to CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE. It is advised to choose cache_size to have "n modulo cache_size == 0": if this is not the case, some elements will always stay in the pool and will never be used. The access to the per-lcore table is of course faster than the multi-producer/consumer pool. The cache can be disabled if the cache_size argument is set to 0; it can be useful to avoid losing objects in cache. Note that even if not used, the memory space for cache is always reserved in a mempool structure, except if CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE is set to 0. </td></tr>
    <tr><td class="paramname">private_data_size</td><td>The size of the private data appended after the mempool structure. This is useful for storing some private data after the mempool structure, as is done for rte_mbuf_pool for example. </td></tr>
    <tr><td class="paramname">mp_init</td><td>A function pointer that is called for initialization of the pool, before object initialization. The user can initialize the private data in this function if needed. This parameter can be NULL if not needed. </td></tr>
    <tr><td class="paramname">mp_init_arg</td><td>An opaque pointer to data that can be used in the mempool constructor function. </td></tr>
    <tr><td class="paramname">obj_init</td><td>A function pointer that is called for each object at initialization of the pool. The user can set some meta data in objects if needed. This parameter can be NULL if not needed. The obj_init() function takes the mempool pointer, the init_arg, the object pointer and the object number as parameters. </td></tr>
    <tr><td class="paramname">obj_init_arg</td><td>An opaque pointer to data that can be used as an argument for each call to the object constructor function. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in the case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>The <em>flags</em> arguments is an OR of following flags:<ul>
<li>MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread between channels in RAM: the pool allocator will add padding between objects depending on the hardware configuration. See Memory alignment constraints for details. If this flag is set, the allocator will just align them to a cache line.</li>
<li>MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are cache-aligned. This flag removes this constraint, and no padding will be present between objects. This flag implies MEMPOOL_F_NO_SPREAD.</li>
<li>MEMPOOL_F_SP_PUT: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put()</a> or <a class="el" href="rte__mempool_8h.html#a46972d2b6e77edd375231453667ce46b">rte_mempool_put_bulk()</a> is "single-producer". Otherwise, it is "multi-producers".</li>
<li>MEMPOOL_F_SC_GET: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#ad1bffea924acb47a9ec321abb21ea0c5">rte_mempool_get()</a> or <a class="el" href="rte__mempool_8h.html#a51a6b5afb4ed66c57c375e7d794e7781">rte_mempool_get_bulk()</a> is "single-consumer". Otherwise, it is "multi-consumers". </li>
</ul>
</td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address of the externally allocated memory buffer. Will be used to store mempool objects. </td></tr>
    <tr><td class="paramname">paddr</td><td>Array of physical addresses of the pages that comprises given memory buffer. </td></tr>
    <tr><td class="paramname">pg_num</td><td>Number of elements in the paddr array. </td></tr>
    <tr><td class="paramname">pg_shift</td><td>LOG2 of the physical pages size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to <a class="el" href="structrte__config.html">rte_config</a> structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - cache size provided is too large</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9ad6189423d5eefaa551c4fb5bf24ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_dom0_mempool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>private_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a429d1d3d79259022df36fc2b5f7db003">rte_mempool_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>mp_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mp_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a6f5c4b0e7f6f6eb0985aed01f745b627">rte_mempool_obj_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>obj_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new mempool named <em>name</em> in memory on Xen Dom0.</p>
<p>This function uses <code><a class="el" href="rte__mempool_8h.html#a5c1921c0e704757b024cb79604db40f4">rte_mempool_xmem_create()</a></code> to allocate memory. The pool contains n elements of elt_size. Its size is set to n. All elements of the mempool are allocated together with the mempool header, and memory buffer can consist of set of disjoint physical pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mempool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">cache_size</td><td>If cache_size is non-zero, the <a class="el" href="structrte__mempool.html">rte_mempool</a> library will try to limit the accesses to the common lockless pool, by maintaining a per-lcore object cache. This argument must be lower or equal to CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE. It is advised to choose cache_size to have "n modulo cache_size == 0": if this is not the case, some elements will always stay in the pool and will never be used. The access to the per-lcore table is of course faster than the multi-producer/consumer pool. The cache can be disabled if the cache_size argument is set to 0; it can be useful to avoid losing objects in cache. Note that even if not used, the memory space for cache is always reserved in a mempool structure, except if CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE is set to 0. </td></tr>
    <tr><td class="paramname">private_data_size</td><td>The size of the private data appended after the mempool structure. This is useful for storing some private data after the mempool structure, as is done for rte_mbuf_pool for example. </td></tr>
    <tr><td class="paramname">mp_init</td><td>A function pointer that is called for initialization of the pool, before object initialization. The user can initialize the private data in this function if needed. This parameter can be NULL if not needed. </td></tr>
    <tr><td class="paramname">mp_init_arg</td><td>An opaque pointer to data that can be used in the mempool constructor function. </td></tr>
    <tr><td class="paramname">obj_init</td><td>A function pointer that is called for each object at initialization of the pool. The user can set some meta data in objects if needed. This parameter can be NULL if not needed. The obj_init() function takes the mempool pointer, the init_arg, the object pointer and the object number as parameters. </td></tr>
    <tr><td class="paramname">obj_init_arg</td><td>An opaque pointer to data that can be used as an argument for each call to the object constructor function. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in the case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>The <em>flags</em> arguments is an OR of following flags:<ul>
<li>MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread between channels in RAM: the pool allocator will add padding between objects depending on the hardware configuration. See Memory alignment constraints for details. If this flag is set, the allocator will just align them to a cache line.</li>
<li>MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are cache-aligned. This flag removes this constraint, and no padding will be present between objects. This flag implies MEMPOOL_F_NO_SPREAD.</li>
<li>MEMPOOL_F_SP_PUT: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put()</a> or <a class="el" href="rte__mempool_8h.html#a46972d2b6e77edd375231453667ce46b">rte_mempool_put_bulk()</a> is "single-producer". Otherwise, it is "multi-producers".</li>
<li>MEMPOOL_F_SC_GET: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#ad1bffea924acb47a9ec321abb21ea0c5">rte_mempool_get()</a> or <a class="el" href="rte__mempool_8h.html#a51a6b5afb4ed66c57c375e7d794e7781">rte_mempool_get_bulk()</a> is "single-consumer". Otherwise, it is "multi-consumers". </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to <a class="el" href="structrte__config.html">rte_config</a> structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - cache size provided is too large</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a97cea3286380dbf5ee641efd8d6c442b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of the mempool to the console.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a305999d4289856a541855ca22dce91ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_mp_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put several objects back in the mempool (multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the mempool from the obj_table. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00837">837</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13e0ad89db728923a7f84e56633346e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_sp_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put several objects back in the mempool (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the mempool from obj_table. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00855">855</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a46972d2b6e77edd375231453667ce46b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put several objects back in the mempool.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at mempool creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the mempool from obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="distributor_2main_8c-example.html#a26">distributor/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00877">877</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13ad267e5cb87337aa1fa83b72ead46f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_mp_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put one object in the mempool (multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00893">893</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a15870119eb7b2816112d44c0fd98b585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_sp_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put one object back in the mempool (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00907">907</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3def6fc59b18be5c983c05de0df5f918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put one object back in the mempool.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at mempool creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a25">multi_process/l2fwd_fork/main.c</a>, <a class="el" href="multi_process_2simple_mp_2main_8c-example.html#a4">multi_process/simple_mp/main.c</a>, and <a class="el" href="multi_process_2simple_mp_2mp_commands_8c-example.html#a3">multi_process/simple_mp/mp_commands.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l00925">925</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a05723e7135fedf8ba6756af8be71e1ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_mc_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get several objects from the mempool (multi-consumers safe).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to get from mempool to obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01030">1030</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d6393ce89533dae2212de148aab30dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_sc_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get several objects from the mempool (NOT multi-consumers safe).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to get from the mempool to obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01059">1059</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a51a6b5afb4ed66c57c375e7d794e7781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get several objects from the mempool.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behaviour that was specified at mempool creation time (see flags).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to get from the mempool to obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="distributor_2main_8c-example.html#a23">distributor/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01091">1091</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a369fa1b1e5d9664c85e94ef58a463b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_mc_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one object from the mempool (multi-consumers safe).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01118">1118</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a47538ab596fd4b69e151f8a8962da8a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_sc_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one object from the mempool (NOT multi-consumers safe).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01140">1140</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad1bffea924acb47a9ec321abb21ea0c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one object from the mempool.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behavior that was specified at mempool creation (see flags).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a23">multi_process/l2fwd_fork/main.c</a>, and <a class="el" href="multi_process_2simple_mp_2mp_commands_8c-example.html#a0">multi_process/simple_mp/mp_commands.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01166">1166</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4e1c868324f15c80e1956ee87249704b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rte_mempool_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of entries in the mempool.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the mempool. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a31">multi_process/l2fwd_fork/main.c</a>, and <a class="el" href="vhost_2main_8c-example.html#a107">vhost/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a80976616504e426555f8eda95050b998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_mempool_free_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of free entries in the mempool ring. i.e. how many entries can be freed back to the mempool.</p>
<p>NOTE: This corresponds to the number of elements <em>allocated</em> from the memory pool, not the number of elements in the pool itself. To count the number elements currently available in the pool, use "rte_mempool_count"</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of free entries in the mempool. </dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01203">1203</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a85a83e5cc7f9d57f154839b1c80992a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_full </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if the mempool is full.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The mempool is full.</li>
<li>0: The mempool is not full. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01222">1222</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6ad83873c9af9bc2012153cd4b4ed52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if the mempool is empty.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The mempool is empty.</li>
<li>0: The mempool is not empty. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01241">1241</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8c8285cccb4078582d361b505891bd0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a> rte_mempool_virt2phy </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>elt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the physical address of elt, which is an element of the pool mp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">elt</td><td>A pointer (virtual address) to the element of the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The physical address of the elt element. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="vhost_2main_8c-example.html#a104">vhost/main.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01257">1257</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b29b84fb7ca24d252abab5f830daa7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_audit </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the consistency of mempool objects.</p>
<p>Verify the coherency of fields in the mempool structure. Also check that the cookies of mempool objects (even the ones that are not present in pool) have a correct value. If not, a panic will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b794c0cd2a78c74817b250becf981fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* rte_mempool_get_priv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the private data in an mempool structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the private data. </dd></dl>

<p>Definition at line <a class="el" href="rte__mempool_8h_source.html#l01294">1294</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb1120319a35b0cf0b23827705b2229a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_list_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of all mempools on the console</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a5887135fc6329a35780b0053e769ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search a mempool from its name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the mempool matching the name, or NULL if not found. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - required entry not available to return. </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a17">multi_process/client_server_mp/mp_client/client.c</a>, <a class="el" href="multi_process_2l2fwd_fork_2main_8c-example.html#a30">multi_process/l2fwd_fork/main.c</a>, <a class="el" href="multi_process_2simple_mp_2main_8c-example.html#a13">multi_process/simple_mp/main.c</a>, and <a class="el" href="multi_process_2symmetric_mp_2main_8c-example.html#a33">multi_process/symmetric_mp/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a121d699436738109067ed80a1ecae38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rte_mempool_calc_obj_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool__objsz.html">rte_mempool_objsz</a> *&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the header, trailer and total size of a mempool element.</p>
<p>Given a desired size of the mempool element and mempool flags, calculates header, trailer, body and total sizes of the mempool object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags used for the mempool creation. Consult <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a> for more information about possible values. The size of each element. </td></tr>
    <tr><td class="paramname">sz</td><td>The calculated detailed size the mempool object. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size of the mempool object. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f017f9b78ab1bc71abd21d0bf233e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rte_mempool_xmem_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elt_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the size of memory required to store mempool elements.</p>
<p>Calculate the maximum amount of memory required to store given number of objects. Assume that the memory buffer will be aligned at page boundary.</p>
<p>Note that if object size is bigger then page size, then it assumes that pages are grouped in subsets of physically continuous pages big enough to store at least one object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt_num</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">elt_sz</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">pg_shift</td><td>LOG2 of the physical pages size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required memory size aligned at page boundary. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bf5dd195fbbb5e0d3b35212bfef534c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rte_mempool_xmem_usage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elt_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a>&#160;</td>
          <td class="paramname"><em>paddr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the size of memory required to store mempool elements.</p>
<p>Calculate how much memory would be actually required with the given memory footprint to store required number of objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address of the externally allocated memory buffer. Will be used to store mempool objects. </td></tr>
    <tr><td class="paramname">elt_num</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">elt_sz</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">paddr</td><td>Array of physical addresses of the pages that comprises given memory buffer. </td></tr>
    <tr><td class="paramname">pg_num</td><td>Number of elements in the paddr array. </td></tr>
    <tr><td class="paramname">pg_shift</td><td>LOG2 of the physical pages size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of bytes needed to store given number of objects, aligned to the given page size. If the provided memory buffer is too small, return a negative value whose absolute value is the actual number of elements that can be stored in that buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac813bddbff225d65d111dda5a1974b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_walk </td>
          <td>(</td>
          <td class="paramtype">void(*)(const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *arg)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk list of all memory pools</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
