

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>24. Packet Framework &mdash; Data Plane Development Kit 16.04.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Data Plane Development Kit 16.04.0 documentation" href="../index.html"/>
        <link rel="up" title="Programmerâ€™s Guide" href="index.html"/>
        <link rel="next" title="25. Vhost Library" href="vhost_lib.html"/>
        <link rel="prev" title="23. Packet Classification and Access Control" href="packet_classif_access_ctrl.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Data Plane Development Kit
          

          
            
            <img src="../_static/DPDK_logo_vertical_rev_small.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                16.04.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xen/index.html">Xen Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programmer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html">2. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="env_abstraction_layer.html">3. Environment Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="ring_lib.html">4. Ring Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mempool_lib.html">5. Mempool Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mbuf_lib.html">6. Mbuf Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="poll_mode_drv.html">7. Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="cryptodev_lib.html">8. Cryptography Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ivshmem_lib.html">9. IVSHMEM Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="link_bonding_poll_mode_drv_lib.html">10. Link Bonding Poll Mode Driver Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer_lib.html">11. Timer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="hash_lib.html">12. Hash Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm_lib.html">13. LPM Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm6_lib.html">14. LPM6 Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_distrib_lib.html">15. Packet Distributor Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="reorder_lib.html">16. Reorder Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_fragment_reassembly_lib.html">17. IP Fragmentation and Reassembly Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_proc_support.html">18. Multi-process Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel_nic_interface.html">19. Kernel NIC Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread_safety_dpdk_functions.html">20. Thread Safety of DPDK Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_framework.html">21. Quality of Service (QoS) Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_man.html">22. Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_classif_access_ctrl.html">23. Packet Classification and Access Control</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">24. Packet Framework</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-objectives">24.1. Design Objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overview">24.2. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#port-library-design">24.3. Port Library Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#port-types">24.3.1. Port Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#port-interface">24.3.2. Port Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#table-library-design">24.4. Table Library Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#table-types">24.4.1. Table Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#table-interface">24.4.2. Table Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hash-table-design">24.4.3. Hash Table Design</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pipeline-library-design">24.5. Pipeline Library Design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#connectivity-of-ports-and-tables">24.5.1. Connectivity of Ports and Tables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#port-actions">24.5.2. Port Actions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#table-actions">24.5.3. Table Actions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#multicore-scaling">24.6. Multicore Scaling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#shared-data-structures">24.6.1. Shared Data Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interfacing-with-accelerators">24.7. Interfacing with Accelerators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vhost_lib.html">25. Vhost Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="port_hotplug_framework.html">26. Port Hotplug Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_org.html">27. Source Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev_kit_build_system.html">28. Development Kit Build System</a></li>
<li class="toctree-l2"><a class="reference internal" href="dev_kit_root_make_help.html">29. Development Kit Root Makefile Help</a></li>
<li class="toctree-l2"><a class="reference internal" href="extend_dpdk.html">30. Extending the DPDK</a></li>
<li class="toctree-l2"><a class="reference internal" href="build_app.html">31. Building Your Own Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ext_app_lib_make_help.html">32. External Application/Library Makefile help</a></li>
<li class="toctree-l2"><a class="reference internal" href="perf_opt_guidelines.html">33. Performance Optimization Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing_efficient_code.html">34. Writing Efficient Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile_app.html">35. Profile Your Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="glossary.html">36. Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_app_ug/index.html">Sample Applications User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor&#8217;s Guidelines</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Data Plane Development Kit</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Programmer&#8217;s Guide</a> &raquo;</li>
      
    <li>24. Packet Framework</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/prog_guide/packet_framework.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="packet-framework">
<h1>24. Packet Framework</h1>
<div class="section" id="design-objectives">
<h2>24.1. Design Objectives</h2>
<p>The main design objectives for the DPDK Packet Framework are:</p>
<ul class="simple">
<li>Provide standard methodology to build complex packet processing pipelines.
Provide reusable and extensible templates for the commonly used pipeline functional blocks;</li>
<li>Provide capability to switch between pure software and hardware-accelerated implementations for the same pipeline functional block;</li>
<li>Provide the best trade-off between flexibility and performance.
Hardcoded pipelines usually provide the best performance, but are not flexible,
while developing flexible frameworks is never a problem, but performance is usually low;</li>
<li>Provide a framework that is logically similar to Open Flow.</li>
</ul>
</div>
<div class="section" id="overview">
<h2>24.2. Overview</h2>
<p>Packet processing applications are frequently structured as pipelines of multiple stages,
with the logic of each stage glued around a lookup table.
For each incoming packet, the table defines the set of actions to be applied to the packet,
as well as the next stage to send the packet to.</p>
<p>The DPDK Packet Framework minimizes the development effort required to build packet processing pipelines
by defining a standard methodology for pipeline development,
as well as providing libraries of reusable templates for the commonly used pipeline blocks.</p>
<p>The pipeline is constructed by connecting the set of input ports with the set of output ports
through the set of tables in a tree-like topology.
As result of lookup operation for the current packet in the current table,
one of the table entries (on lookup hit) or the default table entry (on lookup miss)
provides the set of actions to be applied on the current packet,
as well as the next hop for the packet, which can be either another table, an output port or packet drop.</p>
<p>An example of packet processing pipeline is presented in <a class="reference internal" href="#figure-figure32"><span class="std std-numref">Fig. 24.1</span></a>:</p>
<div class="figure" id="id1">
<span id="figure-figure32"></span><img alt="../_images/figure32.png" src="../_images/figure32.png" />
<p class="caption"><span class="caption-number">Fig. 24.1 </span><span class="caption-text">Example of Packet Processing Pipeline where Input Ports 0 and 1
are Connected with Output Ports 0, 1 and 2 through Tables 0 and 1</span></p>
</div>
</div>
<div class="section" id="port-library-design">
<h2>24.3. Port Library Design</h2>
<div class="section" id="port-types">
<h3>24.3.1. Port Types</h3>
<p><a class="reference internal" href="#table-qos-19"><span class="std std-numref">Table 24.1</span></a> is a non-exhaustive list of ports that can be implemented with the Packet Framework.</p>
<table border="1" class="docutils" id="id2">
<span id="table-qos-19"></span><caption><span class="caption-number">Table 24.1 </span><span class="caption-text">Port Types</caption>
<colgroup>
<col width="3%" />
<col width="17%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Port type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>SW ring</td>
<td>SW circular buffer used for message passing between the application threads. Uses
the DPDK rte_ring primitive. Expected to be the most commonly used type of
port.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>HW ring</td>
<td>Queue of buffer descriptors used to interact with NIC, switch or accelerator ports.
For NIC ports, it uses the DPDK rte_eth_rx_queue or rte_eth_tx_queue
primitives.</td>
</tr>
<tr class="row-even"><td>3</td>
<td>IP reassembly</td>
<td>Input packets are either IP fragments or complete IP datagrams. Output packets are
complete IP datagrams.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>IP fragmentation</td>
<td>Input packets are jumbo (IP datagrams with length bigger than MTU) or non-jumbo
packets. Output packets are non-jumbo packets.</td>
</tr>
<tr class="row-even"><td>5</td>
<td>Traffic manager</td>
<td>Traffic manager attached to a specific NIC output port, performing congestion
management and hierarchical scheduling according to pre-defined SLAs.</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>KNI</td>
<td>Send/receive packets to/from Linux kernel space.</td>
</tr>
<tr class="row-even"><td>7</td>
<td>Source</td>
<td>Input port used as packet generator. Similar to Linux kernel /dev/zero character
device.</td>
</tr>
<tr class="row-odd"><td>8</td>
<td>Sink</td>
<td>Output port used to drop all input packets. Similar to Linux kernel /dev/null
character device.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="port-interface">
<h3>24.3.2. Port Interface</h3>
<p>Each port is unidirectional, i.e. either input port or output port.
Each input/output port is required to implement an abstract interface that
defines the initialization and run-time operation of the port.
The port abstract interface is described in.</p>
<table border="1" class="docutils" id="id3">
<span id="table-qos-20"></span><caption><span class="caption-number">Table 24.2 </span><span class="caption-text">20 Port Abstract Interface</caption>
<colgroup>
<col width="3%" />
<col width="15%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Port Operation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Create</td>
<td>Create the low-level port object (e.g. queue). Can internally allocate memory.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Free</td>
<td>Free the resources (e.g. memory) used by the low-level port object.</td>
</tr>
<tr class="row-even"><td>3</td>
<td>RX</td>
<td>Read a burst of input packets. Non-blocking operation. Only defined for input ports.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>TX</td>
<td>Write a burst of input packets. Non-blocking operation. Only defined for output ports.</td>
</tr>
<tr class="row-even"><td>5</td>
<td>Flush</td>
<td>Flush the output buffer. Only defined for output ports.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="table-library-design">
<h2>24.4. Table Library Design</h2>
<div class="section" id="table-types">
<h3>24.4.1. Table Types</h3>
<p><a class="reference internal" href="#table-qos-21"><span class="std std-numref">Table 24.3</span></a> is a non-exhaustive list of types of tables that can be implemented with the Packet Framework.</p>
<table border="1" class="docutils" id="id4">
<span id="table-qos-21"></span><caption><span class="caption-number">Table 24.3 </span><span class="caption-text">Table Types</caption>
<colgroup>
<col width="3%" />
<col width="26%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Table Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Hash table</td>
<td><p class="first">Lookup key is n-tuple based.</p>
<p>Typically, the lookup key is hashed to produce a signature that is used to
identify a bucket of entries where the lookup key is searched next.</p>
<p>The signature associated with the lookup key of each input packet is either
read from the packet descriptor (pre-computed signature) or computed at
table lookup time.</p>
<p>The table lookup, add entry and delete entry operations, as well as any
other pipeline block that pre-computes the signature all have to use the
same hashing algorithm to generate the signature.</p>
<p class="last">Typically used to implement flow classification tables, ARP caches, routing
table for tunnelling protocols, etc.</p>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Longest Prefix Match (LPM)</td>
<td><p class="first">Lookup key is the IP address.</p>
<p>Each table entries has an associated IP prefix (IP and depth).</p>
<p>The table lookup operation selects the IP prefix that is matched by the
lookup key; in case of multiple matches, the entry with the longest prefix
depth wins.</p>
<p class="last">Typically used to implement IP routing tables.</p>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Access Control List (ACLs)</td>
<td><p class="first">Lookup key is 7-tuple of two VLAN/MPLS labels, IP destination address,
IP source addresses, L4 protocol, L4 destination port, L4 source port.</p>
<p>Each table entry has an associated ACL and priority. The ACL contains bit
masks for the VLAN/MPLS labels, IP prefix for IP destination address, IP
prefix for IP source addresses, L4 protocol and bitmask, L4 destination
port and bit mask, L4 source port and bit mask.</p>
<p>The table lookup operation selects the ACL that is matched by the lookup
key; in case of multiple matches, the entry with the highest priority wins.</p>
<p class="last">Typically used to implement rule databases for firewalls, etc.</p>
</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Pattern matching search</td>
<td><p class="first">Lookup key is the packet payload.</p>
<p>Table is a database of patterns, with each pattern having a priority
assigned.</p>
<p class="last">The table lookup operation selects the patterns that is matched by the
input packet; in case of multiple matches, the matching pattern with the
highest priority wins.</p>
</td>
</tr>
<tr class="row-even"><td>5</td>
<td>Array</td>
<td>Lookup key is the table entry index itself.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="table-interface">
<h3>24.4.2. Table Interface</h3>
<p>Each table is required to implement an abstract interface that defines the initialization
and run-time operation of the table.
The table abstract interface is described in <a class="reference internal" href="#table-qos-29-1"><span class="std std-numref">Table 24.4</span></a>.</p>
<table border="1" class="docutils" id="id5">
<span id="table-qos-29-1"></span><caption><span class="caption-number">Table 24.4 </span><span class="caption-text">Table Abstract Interface</caption>
<colgroup>
<col width="3%" />
<col width="16%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Table operation</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Create</td>
<td>Create the low-level data structures of the lookup table. Can internally allocate
memory.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Free</td>
<td>Free up all the resources used by the lookup table.</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Add entry</td>
<td>Add new entry to the lookup table.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Delete entry</td>
<td>Delete specific entry from the lookup table.</td>
</tr>
<tr class="row-even"><td>5</td>
<td>Lookup</td>
<td><p class="first">Look up a burst of input packets and return a bit mask specifying the result of the
lookup operation for each packet: a set bit signifies lookup hit for the corresponding
packet, while a cleared bit a lookup miss.</p>
<p>For each lookup hit packet, the lookup operation also returns a pointer to the table
entry that was hit, which contains the actions to be applied on the packet and any
associated metadata.</p>
<p class="last">For each lookup miss packet, the actions to be applied on the packet and any
associated metadata are specified by the default table entry preconfigured for lookup
miss.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hash-table-design">
<h3>24.4.3. Hash Table Design</h3>
<div class="section" id="hash-table-overview">
<h4>24.4.3.1. Hash Table Overview</h4>
<p>Hash tables are important because the key lookup operation is optimized for speed:
instead of having to linearly search the lookup key through all the keys in the table,
the search is limited to only the keys stored in a single table bucket.</p>
<p><strong>Associative Arrays</strong></p>
<p>An associative array is a function that can be specified as a set of (key, value) pairs,
with each key from the possible set of input keys present at most once.
For a given associative array, the possible operations are:</p>
<ol class="arabic simple">
<li><em>add (key, value)</em>: When no value is currently associated with <em>key</em>, then the (key, <em>value</em> ) association is created.
When <em>key</em> is already associated value <em>value0</em>, then the association (<em>key</em>, <em>value0</em>) is removed
and association <em>(key, value)</em> is created;</li>
<li><em>delete key</em>: When no value is currently associated with <em>key</em>, this operation has no effect.
When <em>key</em> is already associated  <em>value</em>, then association  <em>(key, value)</em> is removed;</li>
<li><em>lookup key</em>: When no value is currently associated with  <em>key</em>, then this operation returns void value (lookup miss).
When <em>key</em> is associated with <em>value</em>, then this operation returns <em>value</em>.
The <em>(key, value)</em> association is not changed.</li>
</ol>
<p>The matching criterion used to compare the input key against the keys in the associative array is <em>exact match</em>,
as the key size (number of bytes) and the key value (array of bytes) have to match exactly for the two keys under comparison.</p>
<p><strong>Hash Function</strong></p>
<p>A hash function deterministically maps data of variable length (key) to data of fixed size (hash value or key signature).
Typically, the size of the key is bigger than the size of the key signature.
The hash function basically compresses a long key into a short signature.
Several keys can share the same signature (collisions).</p>
<p>High quality hash functions have uniform distribution.
For large number of keys, when dividing the space of signature values into a fixed number of equal intervals (buckets),
it is desirable to have the key signatures evenly distributed across these intervals (uniform distribution),
as opposed to most of the signatures going into only a few of the intervals
and the rest of the intervals being largely unused (non-uniform distribution).</p>
<p><strong>Hash Table</strong></p>
<p>A hash table is an associative array that uses a hash function for its operation.
The reason for using a hash function is to optimize the performance of the lookup operation
by minimizing the number of table keys that have to be compared against the input key.</p>
<p>Instead of storing the (key, value) pairs in a single list, the hash table maintains multiple lists (buckets).
For any given key, there is a single bucket where that key might exist, and this bucket is uniquely identified based on the key signature.
Once the key signature is computed and the hash table bucket identified,
the key is either located in this bucket or it is not present in the hash table at all,
so the key search can be narrowed down from the full set of keys currently in the table
to just the set of keys currently in the identified table bucket.</p>
<p>The performance of the hash table lookup operation is greatly improved,
provided that the table keys are evenly distributed among the hash table buckets,
which can be achieved by using a hash function with uniform distribution.
The rule to map a key to its bucket can simply be to use the key signature (modulo the number of table buckets) as the table bucket ID:</p>
<blockquote>
<div><em>bucket_id = f_hash(key) % n_buckets;</em></div></blockquote>
<p>By selecting the number of buckets to be a power of two, the modulo operator can be replaced by a bitwise AND logical operation:</p>
<blockquote>
<div><em>bucket_id = f_hash(key) &amp; (n_buckets - 1);</em></div></blockquote>
<p>considering <em>n_bits</em> as the number of bits set in <em>bucket_mask = n_buckets - 1</em>,
this means that all the keys that end up in the same hash table bucket have the lower <em>n_bits</em> of their signature identical.
In order to reduce the number of keys in the same bucket (collisions), the number of hash table buckets needs to be increased.</p>
<p>In packet processing context, the sequence of operations involved in hash table operations is described in <a class="reference internal" href="#figure-figure33"><span class="std std-numref">Fig. 24.2</span></a>:</p>
<div class="figure" id="id6">
<span id="figure-figure33"></span><img alt="../_images/figure33.png" src="../_images/figure33.png" />
<p class="caption"><span class="caption-number">Fig. 24.2 </span><span class="caption-text">Sequence of Steps for Hash Table Operations in a Packet Processing Context</span></p>
</div>
</div>
<div class="section" id="hash-table-use-cases">
<h4>24.4.3.2. Hash Table Use Cases</h4>
<p><strong>Flow Classification</strong></p>
<p><em>Description:</em> The flow classification is executed at least once for each input packet.
This operation maps each incoming packet against one of the known traffic flows in the flow database that typically contains millions of flows.</p>
<p><em>Hash table name:</em> Flow classification table</p>
<p><em>Number of keys:</em> Millions</p>
<p><em>Key format:</em> n-tuple of packet fields that uniquely identify a traffic flow/connection.
Example: DiffServ 5-tuple of (Source IP address, Destination IP address, L4 protocol, L4 protocol source port, L4 protocol destination port).
For IPv4 protocol and L4 protocols like TCP, UDP or SCTP, the size of the DiffServ 5-tuple is 13 bytes, while for IPv6 it is 37 bytes.</p>
<p><em>Key value (key data):</em> actions and action meta-data describing what processing to be applied for the packets of the current flow.
The size of the data associated with each traffic flow can vary from 8 bytes to kilobytes.</p>
<p><strong>Address Resolution Protocol (ARP)</strong></p>
<p><em>Description:</em> Once a route has been identified for an IP packet (so the output interface and the IP address of the next hop station are known),
the MAC address of the next hop station is needed in order to send this packet onto the next leg of the journey
towards its destination (as identified by its destination IP address).
The MAC address of the next hop station becomes the destination MAC address of the outgoing Ethernet frame.</p>
<p><em>Hash table name:</em> ARP table</p>
<p><em>Number of keys:</em> Thousands</p>
<p><em>Key format:</em> The pair of (Output interface, Next Hop IP address), which is typically 5 bytes for IPv4 and 17 bytes for IPv6.</p>
<p><em>Key value (key data):</em> MAC address of the next hop station (6 bytes).</p>
</div>
<div class="section" id="hash-table-types">
<h4>24.4.3.3. Hash Table Types</h4>
<p><a class="reference internal" href="#table-qos-22"><span class="std std-numref">Table 24.5</span></a> lists the hash table configuration parameters shared by all different hash table types.</p>
<table border="1" class="docutils" id="id7">
<span id="table-qos-22"></span><caption><span class="caption-number">Table 24.5 </span><span class="caption-text">Configuration Parameters Common for All Hash Table Types</caption>
<colgroup>
<col width="3%" />
<col width="25%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Parameter</th>
<th class="head">Details</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Key size</td>
<td>Measured as number of bytes. All keys have the same size.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Key value (key data) size</td>
<td>Measured as number of bytes.</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Number of buckets</td>
<td>Needs to be a power of two.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Maximum number of keys</td>
<td>Needs to be a power of two.</td>
</tr>
<tr class="row-even"><td>5</td>
<td>Hash function</td>
<td>Examples: jhash, CRC hash, etc.</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>Hash function seed</td>
<td>Parameter to be passed to the hash function.</td>
</tr>
<tr class="row-even"><td>7</td>
<td>Key offset</td>
<td>Offset of the lookup key byte array within the packet meta-data stored in
the packet buffer.</td>
</tr>
</tbody>
</table>
<div class="section" id="bucket-full-problem">
<h5>24.4.3.3.1. Bucket Full Problem</h5>
<p>On initialization, each hash table bucket is allocated space for exactly 4 keys.
As keys are added to the table, it can happen that a given bucket already has 4 keys when a new key has to be added to this bucket.
The possible options are:</p>
<ol class="arabic simple">
<li><strong>Least Recently Used (LRU) Hash Table.</strong>
One of the existing keys in the bucket is deleted and the new key is added in its place.
The number of keys in each bucket never grows bigger than 4. The logic to pick the key to be dropped from the bucket is LRU.
The hash table lookup operation maintains the order in which the keys in the same bucket are hit, so every time a key is hit,
it becomes the new Most Recently Used (MRU) key, i.e. the last candidate for drop.
When a key is added to the bucket, it also becomes the new MRU key.
When a key needs to be picked and dropped, the first candidate for drop, i.e. the current LRU key, is always picked.
The LRU logic requires maintaining specific data structures per each bucket.</li>
<li><strong>Extendable Bucket Hash Table.</strong>
The bucket is extended with space for 4 more keys.
This is done by allocating additional memory at table initialization time,
which is used to create a pool of free keys (the size of this pool is configurable and always a multiple of 4).
On key add operation, the allocation of a group of 4 keys only happens successfully within the limit of free keys,
otherwise the key add operation fails.
On key delete operation, a group of 4 keys is freed back to the pool of free keys
when the key to be deleted is the only key that was used within its group of 4 keys at that time.
On key lookup operation, if the current bucket is in extended state and a match is not found in the first group of 4 keys,
the search continues beyond the first group of 4 keys, potentially until all keys in this bucket are examined.
The extendable bucket logic requires maintaining specific data structures per table and per each bucket.</li>
</ol>
<table border="1" class="docutils" id="id8">
<span id="table-qos-23"></span><caption><span class="caption-number">Table 24.6 </span><span class="caption-text">Configuration Parameters Specific to Extendable Bucket Hash Table</caption>
<colgroup>
<col width="4%" />
<col width="34%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Parameter</th>
<th class="head">Details</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Number of additional keys</td>
<td>Needs to be a power of two, at least equal to 4.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="signature-computation">
<h5>24.4.3.3.2. Signature Computation</h5>
<p>The possible options for key signature computation are:</p>
<ol class="arabic simple">
<li><strong>Pre-computed key signature.</strong>
The key lookup operation is split between two CPU cores.
The first CPU core (typically the CPU core that performs packet RX) extracts the key from the input packet,
computes the key signature and saves both the key and the key signature in the packet buffer as packet meta-data.
The second CPU core reads both the key and the key signature from the packet meta-data
and performs the bucket search step of the key lookup operation.</li>
<li><strong>Key signature computed on lookup (&#8220;do-sig&#8221; version).</strong>
The same CPU core reads the key from the packet meta-data, uses it to compute the key signature
and also performs the bucket search step of the key lookup operation.</li>
</ol>
<table border="1" class="docutils" id="id9">
<span id="table-qos-24"></span><caption><span class="caption-number">Table 24.7 </span><span class="caption-text">Configuration Parameters Specific to Pre-computed Key Signature Hash Table</caption>
<colgroup>
<col width="3%" />
<col width="20%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Parameter</th>
<th class="head">Details</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Signature offset</td>
<td>Offset of the pre-computed key signature within the packet meta-data.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="key-size-optimized-hash-tables">
<h5>24.4.3.3.3. Key Size Optimized Hash Tables</h5>
<p>For specific key sizes, the data structures and algorithm of key lookup operation can be specially handcrafted for further performance improvements,
so following options are possible:</p>
<ol class="arabic simple">
<li><strong>Implementation supporting configurable key size.</strong></li>
<li><strong>Implementation supporting a single key size.</strong>
Typical key sizes are 8 bytes and 16 bytes.</li>
</ol>
</div>
</div>
<div class="section" id="bucket-search-logic-for-configurable-key-size-hash-tables">
<h4>24.4.3.4. Bucket Search Logic for Configurable Key Size Hash Tables</h4>
<p>The performance of the bucket search logic is one of the main factors influencing the performance of the key lookup operation.
The data structures and algorithm are designed to make the best use of Intel CPU architecture resources like:
cache memory space, cache memory bandwidth, external memory bandwidth, multiple execution units working in parallel,
out of order instruction execution, special CPU instructions, etc.</p>
<p>The bucket search logic handles multiple input packets in parallel.
It is built as a pipeline of several stages (3 or 4), with each pipeline stage handling two different packets from the burst of input packets.
On each pipeline iteration, the packets are pushed to the next pipeline stage: for the 4-stage pipeline,
two packets (that just completed stage 3) exit the pipeline,
two packets (that just completed stage 2) are now executing stage 3, two packets (that just completed stage 1) are now executing stage 2,
two packets (that just completed stage 0) are now executing stage 1 and two packets (next two packets to read from the burst of input packets)
are entering the pipeline to execute stage 0.
The pipeline iterations continue until all packets from the burst of input packets execute the last stage of the pipeline.</p>
<p>The bucket search logic is broken into pipeline stages at the boundary of the next memory access.
Each pipeline stage uses data structures that are stored (with high probability) into the L1 or L2 cache memory of the current CPU core and
breaks just before the next memory access required by the algorithm.
The current pipeline stage finalizes by prefetching the data structures required by the next pipeline stage,
so given enough time for the prefetch to complete,
when the next pipeline stage eventually gets executed for the same packets,
it will read the data structures it needs from L1 or L2 cache memory and thus avoid the significant penalty incurred by L2 or L3 cache memory miss.</p>
<p>By prefetching the data structures required by the next pipeline stage in advance (before they are used)
and switching to executing another pipeline stage for different packets,
the number of L2 or L3 cache memory misses is greatly reduced, hence one of the main reasons for improved performance.
This is because the cost of L2/L3 cache memory miss on memory read accesses is high, as usually due to data dependency between instructions,
the CPU execution units have to stall until the read operation is completed from L3 cache memory or external DRAM memory.
By using prefetch instructions, the latency of memory read accesses is hidden,
provided that it is preformed early enough before the respective data structure is actually used.</p>
<p>By splitting the processing into several stages that are executed on different packets (the packets from the input burst are interlaced),
enough work is created to allow the prefetch instructions to complete successfully (before the prefetched data structures are actually accessed) and
also the data dependency between instructions is loosened.
For example, for the 4-stage pipeline, stage 0 is executed on packets 0 and 1 and then,
before same packets 0 and 1 are used (i.e. before stage 1 is executed on packets 0 and 1),
different packets are used: packets 2 and 3 (executing stage 1), packets 4 and 5 (executing stage 2) and packets 6 and 7 (executing stage 3).
By executing useful work while the data structures are brought into the L1 or L2 cache memory, the latency of the read memory accesses is hidden.
By increasing the gap between two consecutive accesses to the same data structure, the data dependency between instructions is loosened;
this allows making the best use of the super-scalar and out-of-order execution CPU architecture,
as the number of CPU core execution units that are active (rather than idle or stalled due to data dependency constraints between instructions) is maximized.</p>
<p>The bucket search logic is also implemented without using any branch instructions.
This avoids the important cost associated with flushing the CPU core execution pipeline on every instance of branch misprediction.</p>
<div class="section" id="configurable-key-size-hash-table">
<h5>24.4.3.4.1. Configurable Key Size Hash Table</h5>
<p><a class="reference internal" href="#figure-figure34"><span class="std std-numref">Fig. 24.3</span></a>, <a class="reference internal" href="#table-qos-25"><span class="std std-numref">Table 24.8</span></a> and <a class="reference internal" href="#table-qos-26"><span class="std std-numref">Table 24.9</span></a> detail the main data structures used to implement configurable key size hash tables (either LRU or extendable bucket,
either with pre-computed signature or &#8220;do-sig&#8221;).</p>
<div class="figure" id="id10">
<span id="figure-figure34"></span><img alt="../_images/figure34.png" src="../_images/figure34.png" />
<p class="caption"><span class="caption-number">Fig. 24.3 </span><span class="caption-text">Data Structures for Configurable Key Size Hash Tables</span></p>
</div>
<table border="1" class="docutils" id="id11">
<span id="table-qos-25"></span><caption><span class="caption-number">Table 24.8 </span><span class="caption-text">Main Large Data Structures (Arrays) used for Configurable Key Size Hash Tables</caption>
<colgroup>
<col width="3%" />
<col width="22%" />
<col width="26%" />
<col width="23%" />
<col width="27%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Array name</th>
<th class="head">Number of entries</th>
<th class="head">Entry size (bytes)</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Bucket array</td>
<td>n_buckets (configurable)</td>
<td>32</td>
<td>Buckets of the hash table.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Bucket extensions array</td>
<td>n_buckets_ext (configurable)</td>
<td>32</td>
<td>This array is only created
for extendable bucket tables.</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Key array</td>
<td>n_keys</td>
<td>key_size (configurable)</td>
<td>Keys added to the hash table.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Data array</td>
<td>n_keys</td>
<td>entry_size (configurable)</td>
<td>Key values (key data)
associated with the hash
table keys.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id12">
<span id="table-qos-26"></span><caption><span class="caption-number">Table 24.9 </span><span class="caption-text">Field Description for Bucket Array Entry (Configurable Key Size Hash Tables)</caption>
<colgroup>
<col width="3%" />
<col width="17%" />
<col width="19%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Field name</th>
<th class="head">Field size (bytes)</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Next Ptr/LRU</td>
<td>8</td>
<td><p class="first">For LRU tables, this fields represents the LRU list for the
current bucket stored as array of 4 entries of 2 bytes each.
Entry 0 stores the index (0 .. 3) of the MRU key, while entry 3
stores the index of the LRU key.</p>
<p class="last">For extendable bucket tables, this field represents the next
pointer (i.e. the pointer to the next group of 4 keys linked to
the current bucket). The next pointer is not NULL if the bucket
is currently extended or NULL otherwise.
To help the branchless implementation, bit 0 (least significant
bit) of this field is set to 1 if the next pointer is not NULL
and to 0 otherwise.</p>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Sig[0 .. 3]</td>
<td>4 x 2</td>
<td><p class="first">If key X (X = 0 .. 3) is valid, then sig X bits 15 .. 1 store
the most significant 15 bits of key X signature and sig X bit 0
is set to 1.</p>
<p class="last">If key X is not valid, then sig X is set to zero.</p>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Key Pos [0 .. 3]</td>
<td>4 x 4</td>
<td><p class="first">If key X is valid (X = 0 .. 3), then Key Pos X represents the
index into the key array where key X is stored, as well as the
index into the data array where the value associated with key X
is stored.</p>
<p class="last">If key X is not valid, then the value of Key Pos X is undefined.</p>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#figure-figure35"><span class="std std-numref">Fig. 24.4</span></a> and <a class="reference internal" href="#table-qos-27"><span class="std std-numref">Table 24.10</span></a> detail the bucket search pipeline stages (either LRU or extendable bucket,
either with pre-computed signature or &#8220;do-sig&#8221;).
For each pipeline stage, the described operations are applied to each of the two packets handled by that stage.</p>
<div class="figure" id="id13">
<span id="figure-figure35"></span><img alt="../_images/figure35.png" src="../_images/figure35.png" />
<p class="caption"><span class="caption-number">Fig. 24.4 </span><span class="caption-text">Bucket Search Pipeline for Key Lookup Operation (Configurable Key Size Hash
Tables)</span></p>
</div>
<table border="1" class="docutils" id="id14">
<span id="table-qos-27"></span><caption><span class="caption-number">Table 24.10 </span><span class="caption-text">Description of the Bucket Search Pipeline Stages (Configurable Key Size Hash Tables)</caption>
<colgroup>
<col width="3%" />
<col width="25%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Stage name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>Prefetch packet meta-data</td>
<td><p class="first">Select next two packets from the burst of input packets.</p>
<p class="last">Prefetch packet meta-data containing the key and key signature.</p>
</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>Prefetch table bucket</td>
<td><p class="first">Read the key signature from the packet meta-data (for extendable bucket hash
tables) or read the key from the packet meta-data and compute key signature
(for LRU tables).</p>
<p>Identify the bucket ID using the key signature.</p>
<p>Set bit 0 of the signature to 1 (to match only signatures of valid keys from
the table).</p>
<p class="last">Prefetch the bucket.</p>
</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Prefetch table key</td>
<td><p class="first">Read the key signatures from the bucket.</p>
<p>Compare the signature of the input key against the 4 key signatures from the
packet. As result, the following is obtained:</p>
<p><em>match</em>
= equal to TRUE if there was at least one signature match and to FALSE in
the case of no signature match;</p>
<p><em>match_many</em>
= equal to TRUE is there were more than one signature matches (can be up to
4 signature matches in the worst case scenario) and to FALSE otherwise;</p>
<p><em>match_pos</em>
= the index of the first key that produced signature match (only valid if
match is true).</p>
<p>For extendable bucket hash tables only, set
<em>match_many</em>
to TRUE if next pointer is valid.</p>
<p class="last">Prefetch the bucket key indicated by
<em>match_pos</em>
(even if
<em>match_pos</em>
does not point to valid key valid).</p>
</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Prefetch table data</td>
<td><p class="first">Read the bucket key indicated by
<em>match_pos</em>.</p>
<p>Compare the bucket key against the input key. As result, the following is
obtained:
<em>match_key</em>
= equal to TRUE if the two keys match and to FALSE otherwise.</p>
<p>Report input key as lookup hit only when both
<em>match</em>
and
<em>match_key</em>
are equal to TRUE and as lookup miss otherwise.</p>
<p>For LRU tables only, use branchless logic to update the bucket LRU list
(the current key becomes the new MRU) only on lookup hit.</p>
<p class="last">Prefetch the key value (key data) associated with the current key (to avoid
branches, this is done on both lookup hit and miss).</p>
</td>
</tr>
</tbody>
</table>
<p>Additional notes:</p>
<ol class="arabic simple">
<li>The pipelined version of the bucket search algorithm is executed only if there are at least 7 packets in the burst of input packets.
If there are less than 7 packets in the burst of input packets,
a non-optimized implementation of the bucket search algorithm is executed.</li>
<li>Once the pipelined version of the bucket search algorithm has been executed for all the packets in the burst of input packets,
the non-optimized implementation of the bucket search algorithm is also executed for any packets that did not produce a lookup hit,
but have the <em>match_many</em> flag set.
As result of executing the non-optimized version, some of these packets may produce a lookup hit or lookup miss.
This does not impact the performance of the key lookup operation,
as the probability of matching more than one signature in the same group of 4 keys or of having the bucket in extended state
(for extendable bucket hash tables only) is relatively small.</li>
</ol>
<p><strong>Key Signature Comparison Logic</strong></p>
<p>The key signature comparison logic is described in <a class="reference internal" href="#table-qos-28"><span class="std std-numref">Table 24.11</span></a>.</p>
<table border="1" class="docutils" id="id15">
<span id="table-qos-28"></span><caption><span class="caption-number">Table 24.11 </span><span class="caption-text">Lookup Tables for Match, Match_Many and Match_Pos</caption>
<colgroup>
<col width="6%" />
<col width="9%" />
<col width="23%" />
<col width="31%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>#</td>
<td>mask</td>
<td>match (1 bit)</td>
<td>match_many (1 bit)</td>
<td>match_pos (2 bits)</td>
</tr>
<tr class="row-even"><td>0</td>
<td>0000</td>
<td>0</td>
<td>0</td>
<td>00</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0001</td>
<td>1</td>
<td>0</td>
<td>00</td>
</tr>
<tr class="row-even"><td>2</td>
<td>0010</td>
<td>1</td>
<td>0</td>
<td>01</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>0011</td>
<td>1</td>
<td>1</td>
<td>00</td>
</tr>
<tr class="row-even"><td>4</td>
<td>0100</td>
<td>1</td>
<td>0</td>
<td>10</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>0101</td>
<td>1</td>
<td>1</td>
<td>00</td>
</tr>
<tr class="row-even"><td>6</td>
<td>0110</td>
<td>1</td>
<td>1</td>
<td>01</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>0111</td>
<td>1</td>
<td>1</td>
<td>00</td>
</tr>
<tr class="row-even"><td>8</td>
<td>1000</td>
<td>1</td>
<td>0</td>
<td>11</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>1001</td>
<td>1</td>
<td>1</td>
<td>00</td>
</tr>
<tr class="row-even"><td>10</td>
<td>1010</td>
<td>1</td>
<td>1</td>
<td>01</td>
</tr>
<tr class="row-odd"><td>11</td>
<td>1011</td>
<td>1</td>
<td>1</td>
<td>00</td>
</tr>
<tr class="row-even"><td>12</td>
<td>1100</td>
<td>1</td>
<td>1</td>
<td>10</td>
</tr>
<tr class="row-odd"><td>13</td>
<td>1101</td>
<td>1</td>
<td>1</td>
<td>00</td>
</tr>
<tr class="row-even"><td>14</td>
<td>1110</td>
<td>1</td>
<td>1</td>
<td>01</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>1111</td>
<td>1</td>
<td>1</td>
<td>00</td>
</tr>
</tbody>
</table>
<p>The input <em>mask</em> hash bit X (X = 0 .. 3) set to 1 if input signature is equal to bucket signature X and set to 0 otherwise.
The outputs <em>match</em>, <em>match_many</em> and <em>match_pos</em> are 1 bit, 1 bit and 2 bits in size respectively and their meaning has been explained above.</p>
<p>As displayed in <a class="reference internal" href="#table-qos-29"><span class="std std-numref">Table 24.12</span></a>, the lookup tables for <em>match</em> and <em>match_many</em> can be collapsed into a single 32-bit value and the lookup table for
<em>match_pos</em> can be collapsed into a 64-bit value.
Given the input <em>mask</em>, the values for <em>match</em>, <em>match_many</em> and <em>match_pos</em> can be obtained by indexing their respective bit array to extract 1 bit,
1 bit and 2 bits respectively with branchless logic.</p>
<table border="1" class="docutils" id="id16">
<span id="table-qos-29"></span><caption><span class="caption-number">Table 24.12 </span><span class="caption-text">Collapsed Lookup Tables for Match, Match_Many and Match_Pos</caption>
<colgroup>
<col width="16%" />
<col width="58%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>&nbsp;</td>
<td>Bit array</td>
<td>Hexadecimal value</td>
</tr>
<tr class="row-even"><td>match</td>
<td>1111_1111_1111_1110</td>
<td>0xFFFELLU</td>
</tr>
<tr class="row-odd"><td>match_many</td>
<td>1111_1110_1110_1000</td>
<td>0xFEE8LLU</td>
</tr>
<tr class="row-even"><td>match_pos</td>
<td>0001_0010_0001_0011__0001_0010_0001_0000</td>
<td>0x12131210LLU</td>
</tr>
</tbody>
</table>
<p>The pseudo-code for match, match_many and match_pos is:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>match = (0xFFFELLU &gt;&gt; mask) &amp; 1;

match_many = (0xFEE8LLU &gt;&gt; mask) &amp; 1;

match_pos = (0x12131210LLU &gt;&gt; (mask &lt;&lt; 1)) &amp; 3;
</pre></div>
</div>
</div>
<div class="section" id="single-key-size-hash-tables">
<h5>24.4.3.4.2. Single Key Size Hash Tables</h5>
<p><a class="reference internal" href="#figure-figure37"><span class="std std-numref">Fig. 24.5</span></a>, <a class="reference internal" href="#figure-figure38"><span class="std std-numref">Fig. 24.6</span></a>, <a class="reference internal" href="#table-qos-30"><span class="std std-numref">Table 24.13</span></a> and <a class="reference internal" href="#table-qos-31"><span class="std std-numref">Table 24.14</span></a> detail the main data structures used to implement 8-byte and 16-byte key hash tables
(either LRU or extendable bucket, either with pre-computed signature or &#8220;do-sig&#8221;).</p>
<div class="figure" id="id17">
<span id="figure-figure37"></span><img alt="../_images/figure37.png" src="../_images/figure37.png" />
<p class="caption"><span class="caption-number">Fig. 24.5 </span><span class="caption-text">Data Structures for 8-byte Key Hash Tables</span></p>
</div>
<div class="figure" id="id18">
<span id="figure-figure38"></span><img alt="../_images/figure38.png" src="../_images/figure38.png" />
<p class="caption"><span class="caption-number">Fig. 24.6 </span><span class="caption-text">Data Structures for 16-byte Key Hash Tables</span></p>
</div>
<table border="1" class="docutils" id="id19">
<span id="table-qos-30"></span><caption><span class="caption-number">Table 24.13 </span><span class="caption-text">Main Large Data Structures (Arrays) used for 8-byte and 16-byte Key Size Hash Tables</caption>
<colgroup>
<col width="3%" />
<col width="22%" />
<col width="26%" />
<col width="19%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Array name</th>
<th class="head">Number of entries</th>
<th class="head">Entry size (bytes)</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Bucket array</td>
<td>n_buckets (configurable)</td>
<td><p class="first"><em>8-byte key size:</em></p>
<p>64 + 4 x entry_size</p>
<p><em>16-byte key size:</em></p>
<p class="last">128 + 4 x entry_size</p>
</td>
<td>Buckets of the hash table.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Bucket extensions array</td>
<td>n_buckets_ext (configurable)</td>
<td><p class="first"><em>8-byte key size:</em></p>
<p>64 + 4 x entry_size</p>
<p><em>16-byte key size:</em></p>
<p class="last">128 + 4 x entry_size</p>
</td>
<td>This array is only created for
extendable bucket tables.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id20">
<span id="table-qos-31"></span><caption><span class="caption-number">Table 24.14 </span><span class="caption-text">Field Description for Bucket Array Entry (8-byte and 16-byte Key Hash Tables)</caption>
<colgroup>
<col width="3%" />
<col width="13%" />
<col width="17%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Field name</th>
<th class="head">Field size (bytes)</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Valid</td>
<td>8</td>
<td><p class="first">Bit X (X = 0 .. 3) is set to 1 if key X is valid or to 0 otherwise.</p>
<p class="last">Bit 4 is only used for extendable bucket tables to help with the
implementation of the branchless logic. In this case, bit 4 is set to 1 if
next pointer is valid (not NULL) or to 0 otherwise.</p>
</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Next Ptr/LRU</td>
<td>8</td>
<td><p class="first">For LRU tables, this fields represents the LRU list for the current bucket
stored as array of 4 entries of 2 bytes each. Entry 0 stores the index
(0 .. 3) of the MRU key, while entry 3 stores the index of the LRU key.</p>
<p class="last">For extendable bucket tables, this field represents the next pointer (i.e.
the pointer to the next group of 4 keys linked to the current bucket). The
next pointer is not NULL if the bucket is currently extended or NULL
otherwise.</p>
</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Key [0 .. 3]</td>
<td>4 x key_size</td>
<td>Full keys.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Data [0 .. 3]</td>
<td>4 x entry_size</td>
<td>Full key values (key data) associated with keys 0 .. 3.</td>
</tr>
</tbody>
</table>
<p>and detail the bucket search pipeline used to implement 8-byte and 16-byte key hash tables (either LRU or extendable bucket,
either with pre-computed signature or &#8220;do-sig&#8221;).
For each pipeline stage, the described operations are applied to each of the two packets handled by that stage.</p>
<div class="figure" id="id21">
<span id="figure-figure39"></span><img alt="../_images/figure39.png" src="../_images/figure39.png" />
<p class="caption"><span class="caption-number">Fig. 24.7 </span><span class="caption-text">Bucket Search Pipeline for Key Lookup Operation (Single Key Size Hash
Tables)</span></p>
</div>
<table border="1" class="docutils" id="id22">
<span id="table-qos-32"></span><caption><span class="caption-number">Table 24.15 </span><span class="caption-text">Description of the Bucket Search Pipeline Stages (8-byte and 16-byte Key Hash Tables)</caption>
<colgroup>
<col width="3%" />
<col width="25%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Stage name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>Prefetch packet meta-data</td>
<td><ol class="first last arabic simple">
<li>Select next two packets from the burst of input packets.</li>
<li>Prefetch packet meta-data containing the key and key signature.</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>Prefetch table bucket</td>
<td><ol class="first last arabic simple">
<li>Read the key signature from the packet meta-data (for extendable bucket
hash tables) or read the key from the packet meta-data and compute key
signature (for LRU tables).</li>
<li>Identify the bucket ID using the key signature.</li>
<li>Prefetch the bucket.</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Prefetch table data</td>
<td><ol class="first last arabic simple">
<li>Read the bucket.</li>
<li>Compare all 4 bucket keys against the input key.</li>
<li>Report input key as lookup hit only when a match is identified (more
than one key match is not possible)</li>
<li>For LRU tables only, use branchless logic to update the bucket LRU list
(the current key becomes the new MRU) only on lookup hit.</li>
<li>Prefetch the key value (key data) associated with the matched key (to
avoid branches, this is done on both lookup hit and miss).</li>
</ol>
</td>
</tr>
</tbody>
</table>
<p>Additional notes:</p>
<ol class="arabic simple">
<li>The pipelined version of the bucket search algorithm is executed only if there are at least 5 packets in the burst of input packets.
If there are less than 5 packets in the burst of input packets, a non-optimized implementation of the bucket search algorithm is executed.</li>
<li>For extendable bucket hash tables only,
once the pipelined version of the bucket search algorithm has been executed for all the packets in the burst of input packets,
the non-optimized implementation of the bucket search algorithm is also executed for any packets that did not produce a lookup hit,
but have the bucket in extended state.
As result of executing the non-optimized version, some of these packets may produce a lookup hit or lookup miss.
This does not impact the performance of the key lookup operation,
as the probability of having the bucket in extended state is relatively small.</li>
</ol>
</div>
</div>
</div>
</div>
<div class="section" id="pipeline-library-design">
<h2>24.5. Pipeline Library Design</h2>
<p>A pipeline is defined by:</p>
<ol class="arabic simple">
<li>The set of input ports;</li>
<li>The set of output ports;</li>
<li>The set of tables;</li>
<li>The set of actions.</li>
</ol>
<p>The input ports are connected with the output ports through tree-like topologies of interconnected tables.
The table entries contain the actions defining the operations to be executed on the input packets and the packet flow within the pipeline.</p>
<div class="section" id="connectivity-of-ports-and-tables">
<h3>24.5.1. Connectivity of Ports and Tables</h3>
<p>To avoid any dependencies on the order in which pipeline elements are created,
the connectivity of pipeline elements is defined after all the pipeline input ports,
output ports and tables have been created.</p>
<p>General connectivity rules:</p>
<ol class="arabic simple">
<li>Each input port is connected to a single table. No input port should be left unconnected;</li>
<li>The table connectivity to other tables or to output ports is regulated by the next hop actions of each table entry and the default table entry.
The table connectivity is fluid, as the table entries and the default table entry can be updated during run-time.<ul>
<li>A table can have multiple entries (including the default entry) connected to the same output port.
A table can have different entries connected to different output ports.
Different tables can have entries (including default table entry) connected to the same output port.</li>
<li>A table can have multiple entries (including the default entry) connected to another table,
in which case all these entries have to point to the same table.
This constraint is enforced by the API and prevents tree-like topologies from being created (allowing table chaining only),
with the purpose of simplifying the implementation of the pipeline run-time execution engine.</li>
</ul>
</li>
</ol>
</div>
<div class="section" id="port-actions">
<h3>24.5.2. Port Actions</h3>
<div class="section" id="port-action-handler">
<h4>24.5.2.1. Port Action Handler</h4>
<p>An action handler can be assigned to each input/output port to define actions to be executed on each input packet that is received by the port.
Defining the action handler for a specific input/output port is optional (i.e. the action handler can be disabled).</p>
<p>For input ports, the action handler is executed after RX function. For output ports, the action handler is executed before the TX function.</p>
<p>The action handler can decide to drop packets.</p>
</div>
</div>
<div class="section" id="table-actions">
<h3>24.5.3. Table Actions</h3>
<div class="section" id="table-action-handler">
<h4>24.5.3.1. Table Action Handler</h4>
<p>An action handler to be executed on each input packet can be assigned to each table.
Defining the action handler for a specific table is optional (i.e. the action handler can be disabled).</p>
<p>The action handler is executed after the table lookup operation is performed and the table entry associated with each input packet is identified.
The action handler can only handle the user-defined actions, while the reserved actions (e.g. the next hop actions) are handled by the Packet Framework.
The action handler can decide to drop the input packet.</p>
</div>
<div class="section" id="reserved-actions">
<h4>24.5.3.2. Reserved Actions</h4>
<p>The reserved actions are handled directly by the Packet Framework without the user being able to change their meaning
through the table action handler configuration.
A special category of the reserved actions is represented by the next hop actions, which regulate the packet flow between input ports,
tables and output ports through the pipeline.
<a class="reference internal" href="#table-qos-33"><span class="std std-numref">Table 24.16</span></a> lists the next hop actions.</p>
<table border="1" class="docutils" id="id23">
<span id="table-qos-33"></span><caption><span class="caption-number">Table 24.16 </span><span class="caption-text">Next Hop Actions (Reserved)</caption>
<colgroup>
<col width="3%" />
<col width="20%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Next hop action</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Drop</td>
<td>Drop the current packet.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Send to output port</td>
<td>Send the current packet to specified output port. The output port ID is metadata
stored in the same table entry.</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Send to table</td>
<td>Send the current packet to specified table. The table ID is metadata stored in
the same table entry.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="user-actions">
<h4>24.5.3.3. User Actions</h4>
<p>For each table, the meaning of user actions is defined through the configuration of the table action handler.
Different tables can be configured with different action handlers, therefore the meaning of the user actions
and their associated meta-data is private to each table.
Within the same table, all the table entries (including the table default entry) share the same definition
for the user actions and their associated meta-data,
with each table entry having its own set of enabled user actions and its own copy of the action meta-data.
<a class="reference internal" href="#table-qos-34"><span class="std std-numref">Table 24.17</span></a> contains a non-exhaustive list of user action examples.</p>
<table border="1" class="docutils" id="id24">
<span id="table-qos-34"></span><caption><span class="caption-number">Table 24.17 </span><span class="caption-text">User Action Examples</caption>
<colgroup>
<col width="3%" />
<col width="33%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">User action</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Metering</td>
<td>Per flow traffic metering using the srTCM and trTCM algorithms.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Statistics</td>
<td>Update the statistics counters maintained per flow.</td>
</tr>
<tr class="row-even"><td>3</td>
<td>App ID</td>
<td>Per flow state machine fed by variable length sequence of packets
at the flow initialization with the purpose of identifying the
traffic type and application.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Push/pop labels</td>
<td>Push/pop VLAN/MPLS labels to/from the current packet.</td>
</tr>
<tr class="row-even"><td>5</td>
<td>Network Address Translation (NAT)</td>
<td>Translate between the internal (LAN) and external (WAN) IP
destination/source address and/or L4 protocol destination/source
port.</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>TTL update</td>
<td>Decrement IP TTL and, in case of IPv4 packets, update the IP
checksum.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="multicore-scaling">
<h2>24.6. Multicore Scaling</h2>
<p>A complex application is typically split across multiple cores, with cores communicating through SW queues.
There is usually a performance limit on the number of table lookups
and actions that can be fitted on the same CPU core due to HW constraints like:
available CPU cycles, cache memory size, cache transfer BW, memory transfer BW, etc.</p>
<p>As the application is split across multiple CPU cores, the Packet Framework facilitates the creation of several pipelines,
the assignment of each such pipeline to a different CPU core
and the interconnection of all CPU core-level pipelines into a single application-level complex pipeline.
For example, if CPU core A is assigned to run pipeline P1 and CPU core B pipeline P2,
then the interconnection of P1 with P2 could be achieved by having the same set of SW queues act like output ports
for P1 and input ports for P2.</p>
<p>This approach enables the application development using the pipeline, run-to-completion (clustered) or hybrid (mixed) models.</p>
<p>It is allowed for the same core to run several pipelines, but it is not allowed for several cores to run the same pipeline.</p>
<div class="section" id="shared-data-structures">
<h3>24.6.1. Shared Data Structures</h3>
<p>The threads performing table lookup are actually table writers rather than just readers.
Even if the specific table lookup algorithm is thread-safe for multiple readers
(e. g. read-only access of the search algorithm data structures is enough to conduct the lookup operation),
once the table entry for the current packet is identified, the thread is typically expected to update the action meta-data stored in the table entry
(e.g. increment the counter tracking the number of packets that hit this table entry), and thus modify the table entry.
During the time this thread is accessing this table entry (either writing or reading; duration is application specific),
for data consistency reasons, no other threads (threads performing table lookup or entry add/delete operations) are allowed to modify this table entry.</p>
<p>Mechanisms to share the same table between multiple threads:</p>
<ol class="arabic simple">
<li><strong>Multiple writer threads.</strong>
Threads need to use synchronization primitives like semaphores (distinct semaphore per table entry) or atomic instructions.
The cost of semaphores is usually high, even when the semaphore is free.
The cost of atomic instructions is normally higher than the cost of regular instructions.</li>
<li><strong>Multiple writer threads, with single thread performing table lookup operations and multiple threads performing table entry add/delete operations.</strong>
The threads performing table entry add/delete operations send table update requests to the reader (typically through message passing queues),
which does the actual table updates and then sends the response back to the request initiator.</li>
<li><strong>Single writer thread performing table entry add/delete operations and multiple reader threads that perform table lookup operations with read-only access to the table entries.</strong>
The reader threads use the main table copy while the writer is updating the mirror copy.
Once the writer update is done, the writer can signal to the readers and busy wait until all readers swaps between the mirror copy (which now becomes the main copy) and
the mirror copy (which now becomes the main copy).</li>
</ol>
</div>
</div>
<div class="section" id="interfacing-with-accelerators">
<h2>24.7. Interfacing with Accelerators</h2>
<p>The presence of accelerators is usually detected during the initialization phase by inspecting the HW devices that are part of the system (e.g. by PCI bus enumeration).
Typical devices with acceleration capabilities are:</p>
<ul class="simple">
<li>Inline accelerators: NICs, switches, FPGAs, etc;</li>
<li>Look-aside accelerators: chipsets, FPGAs, etc.</li>
</ul>
<p>Usually, to support a specific functional block, specific implementation of Packet Framework tables and/or ports and/or actions has to be provided for each accelerator,
with all the implementations sharing the same API: pure SW implementation (no acceleration), implementation using accelerator A, implementation using accelerator B, etc.
The selection between these implementations could be done at build time or at run-time (recommended), based on which accelerators are present in the system,
with no application changes required.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="vhost_lib.html" class="btn btn-neutral float-right" title="25. Vhost Library" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="packet_classif_access_ctrl.html" class="btn btn-neutral" title="23. Packet Classification and Access Control" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'16.04.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>