# Memory中的Channel/Bank/Rank解析

最近在看网卡底层驱动的一些资料，被内存`bank`，`rank`，`channel`这些关于`memory`的名词搞得绕来绕去，网上查了一些资料，说得也不全面。在这里让我们一步一步来拆解`memory`的神秘面纱，从架构到读写逐步解开这块秘密。

## 发挥性`memory`分两种，`SRAM`与`DRAM`
`RAM(Random Access Memory)`随机存取内存，之所以叫做“随机存取”，是因为相对于早期现行存储媒介（磁带？很久以前的）而言，因为磁带的存取是线性的（还记得快进/倒带 那个滋溜爽），存取时间由目前磁带位置和目的位置的距离而定（类似数据结构中的线性表）。需要转动刺头到应有的位置，因此距离越长，转的就越久了，读写时间也越久。而伟大的`RAM`没有这种限制，存取时间为固定值（类似数组这种下表式访问，下标就是地址），不会因为存储资料在`memory`中的位置而影响读取时间。

`RAM`大致可以分为两种：`SRAM`与`DRAM`，这两者基本原理上有相同的地方，都是将电荷存储到记忆体内部，由此针对不同的电荷存储0 or 1. `SRAM(Static Random Access Memory)`静态随机存储memory和`DRAM(Dynamic Random Access Memory)`有几点不同：`SRAM`的结构比较复杂，单位面积的容量少，存取速度很快；`DRAM`则结构简单，单位面积存储的容量比较多，存取时间相对`SRAM`慢，同时`DRAM`因为构造比较简单，存储的电荷惠随着时间逐渐消失，因此需要定时再充电（`Refresh`），以保持电容存储的资料。

![SRAM一个单位存储区的构造](http://cdn1.techbang.com.tw/system/images/164313/original/66659bce5ad5205147d2b08a1ebe8e12.jpg?1401350005)

![DRAM 單一位元儲存區的構造。](http://cdn1.techbang.com.tw/system/images/164601/original/2f4e6d1288b5a1c50b8a3f37cf59855f.jpg?1401477894)

由图中的`SRAM`和`DRAM`构造可以知道，`SRAM`采用正反三极管+电容（`flip-flop`）构造存储器，`DRAM`则是采用电容式存储（md，这两图看着好熟悉，就是看不懂早忘了，欲哭无泪）。因为`SRAM`和`DRAM`的种种特性上的不同，`SRAM`比较适合作为暂存器，配合CPU快速存取使用。`DRAM`则适合作为主要的memory记忆体而使用。

> 挥发性记忆体与非挥发性记忆体
挥发性记忆体(`Volatile Memory`)和非挥发性记忆体(`Non-Volatile Memory`)之间的差异在于，断电之后是否还可以保存内部存储的资料。挥发性记忆体的资料将会随着失去电力的供应而消失，而非挥发性记忆体依然可以保存有内部的资料。

## 内存子系统
`DRAM`由于构造简单，高密度，作为电脑内部的主要记忆体非常适合。但由于主存通常放在`CPU`之外，从工厂出来的颗粒需要封装和组合之后才可以和`CPU`相连，因此从`CPU`到`DRAM`颗粒之间依次按层级由大到小分为`channel > DIMM > rank > chip > bank > row/column`。（和lz之前想的差不多，就跟先到哪条街道，哪个小区单元，哪个栋楼，几层几单元的地址格局一样）。下面，让我们来一一说明这些部分：

内存的结构（从上往下，由大到小）

![内存的结构（从上往下，由大到小）](http://cdn3.techbang.com.tw/system/images/164318/original/8f04a1f57fe07692327b9269ba484ce4.jpg?1401354086)

内存从channel到chip的对应关系。这里特别要注意，rank和内存条的面没有必然关系，虽然图中这么画了，但是不要误导大家，就是示意一下，下面会有详细介绍。

![内存从channel到chip的对应关系](http://cdn1.techbang.com.tw/system/images/164600/original/9db89369284749feaa291ef48931618d.jpg?1401477760)

chip 再往下拆分为 bank

![chip 再往下拆分为 bank](http://cdn3.techbang.com.tw/system/images/164316/original/93ec9064210ad7d3091dbf8569b680be.jpg?1401353131)

bank 再往下拆分就是一个个的存储单位，横排为`row`，纵列为`column`，每排`column`的下方都有一个`row buffer`，用来暂存刚刚读取出来的某个`row`排的资料。(是不是很简单，是不是很像你家小区的格局？Yeah！so easy ~)

![bank再往下拆分](http://cdn1.techbang.com.tw/system/images/164317/original/a7e04928ab16fb4cef18df7739f26c0f.jpg?1401354037)

单个DRAM颗粒内部的功能区块图（图片来自Micron)

![单个DRAM颗粒内部的功能区块图（图片来自Micron)](http://cdn3.techbang.com.tw/system/images/164602/original/236a3b14df3a455ee7d783645f11a0f2.png?1401479387)

## `channel`和 `DIMM`
从内存控制器出来之后，最先到达的是`channel`，每个`channel`都需要配有一组内存控制器，2个`channel`两个……以此类推。而每个`channel`中能够有很多组`DIMM(Dual In-line Memory Module)`，`DIMM`就是目前能够在消费市场上买到的大家平时能看到的内存模组。因为n多年前的主板必须购买内存颗粒（chip）自己插在主板上（想想知道为啥那时候大师都厉害了吧，这组成原理在实践中就得到了锻炼），然后发展出`SIMM (Single In-line Memory Module)`，将多组内存颗粒(`chip`)焊在一块电路板上，成为内存模组，再将次电路板插在主板上。接着为了增加吞吐量，将一条内存模组的位宽从`SIMM`的32bit升级到`DIMM`的64bit，这个设计沿用至今。

从内存颗粒过度到`SIMM`的时代，坊间曾出现替使用者将内存颗粒焊接到`SIMM`电路板上的私活，因为当时的内存条非常贵，所以稍微花点小钱就可以把内存颗粒换到新的电脑上。

## `rank`和`chip`

`rank`指的是连接到同一个`cs(Chip Select，片选)`的所有内存颗粒chips，内存控制器能够对同一个`rank`的所有chips同时进行读写操作，而在同一个`rank`的`chip`也分享同样的控制信号。以目前的电脑来说，因为一组channel的位宽是64bit，所以能够同时读写8byte的资料，如果是具有`ECC`功能的内存控制器和`ECC`内存模组，那么一组channel的位宽就是72bit。

![rank](http://cdn1.techbang.com.tw/system/images/164319/original/d3183967a313519b728ad070ec71aa17.jpg?1401356864)

rank1和rank2共享同一组`addr/command`信号线，利用cs片选线选择欲读取或是写入的那一组，之后将存储内容经由`MUX`多路器送出。

很多人有错误的理解，常以`chip`的数量或是以内存模组的单/双面对`rank`进行判断，但实际上应该以内存控制器和内存颗粒的规格进行判断。目前家用PC的内存控制器通道绝大部分是64bit宽，内存颗粒的位宽是8bit。因此8颗颗粒就可以满足内存控制器的需求，也就是一组`rank`。但偶尔也有以16bit位宽的内存颗粒制成的内存模组，此时4个颗粒chip就是一组`rank`。

这在采用Intel H61/H81 芯片组 和 传统单channel的主板时需要特别注意，因为Intel限制H64/H81每个channel仅能支持2组`rank`，而不是4组`rank`，部分主板每个channel又做了2组内存模组插槽，造成部分使用者同组channel放入2条内存模组（内存条）时能够识别全部的内存容量（对于双面单`rank`的内存模组是这样），然而部分使用者则仅能识别一半的容量（双面双`rank`的内存模组）。

## `bank`，`row`，`column`

`bank`再往下分就是实际存储单位元的电路，一般来说横向选择排数的线路称为`row(row enable, row select, word line)`，纵向负责传送信号的线路称为`column(bitline)`，每组`bank`的下方还会有个`row buffer(sense amplifer)`，负责将读出的`row`内容暂存，等待`column`位址送到后输出正确的位元，以及判断存储的内容是0还是1.

一个bank的读取操作。

![一个bank的读取操作](http://cdn2.techbang.com.tw/system/images/164376/original/8b5f20f18325626d9b01a7d489395306.jpg?1401360280)

一个bank的写入操作。

![一个bank的写入操作](http://cdn3.techbang.com.tw/system/images/164443/original/8463bd3e8722955476902b61ba2f4eaf.jpg?1401370331)

## 内存的读写方式
上图标明了内存的读写方式，读取时首先内存控制器将1组位址现传到内存上，控制器跟着传送控制信号；如果是多`rank`的情况，`CS`也会送到对应信号选择的目标`rank`上。接着由于每个`rank`是由多个`chip`组成，每个`chip`仅负责部分的资料读取，`chip`接收到位址信号后，将位址放入内部的`row/column`解码器找出对应的`bank`位址（每家厂商每款产品内部的`bank`组合可能不同，因此相应地也会略有不同），接着开启`row`线，同一排`row`的内部内容就会流到`row buffer`内部，`row buffer`判断信号为0或是1之后就输出存储内容。

写入时除了位址资料以外，还会传送欲写入的内容至芯片内部的`input buffer`，同样的也是按照`row/column`解码器找出对应位址之后写入。


内存控制器和DIMM之间的线路关系

![記憶體控制器和 DIMM 之間線路的關係。](http://cdn3.techbang.com.tw/system/images/164533/original/daabc6d73ae47f6909ab26ab5a5fc0e6.jpg?1401443446)

## 越多越好，加速读写能力
家用电脑的内存控制器已经进入双通道内存控制器多年，加速原理为增加位宽，达到同时读写更多资料的能力。

另一种增加频宽的方法就是减少延迟，利用多个`chip`或是`bank`达成。一般的内存读取延迟为 命令下达 + 内存读取延迟 + 输出内容，如果命令下达延迟为2ns，内存读取延迟为10ns，输出内容延迟为2ns，那么读取两笔资料的延迟就是 (2+10+2) × 2 = 28ns。

如果能够将资料拆分到2颗内存颗粒上，那么这两笔读取延迟将降低至2+2+10+2=16ns，因为不需要等到前面一笔资料的读取完成才发出下一笔的读取命令，在第一笔资料进入内存读取时就可发出。这种概念也可应用到目前的SSD上，较多的`ce`分装的快速记忆芯片，通常都比较少`ce`封装的芯片来得快。


由时序图可以知道，下凡此种尽量拆分内存空间的作法，可以大幅减少延迟。

![由時序圖可得知，下方此種盡量分拆記憶體空間的作法，可大幅減少延遲。](http://cdn1.techbang.com.tw/system/images/164534/original/387eb4106c7b1f96eb83ab98af6d940d.jpg?1401446040)


内存rank概念和区分
1：什么是RANK?
答：CPU与内存之间的接口位宽是64bit，也就意味着CPU在一个时钟周期内会向内存发送或从内存读取64bit的数据。可是，单个内存颗粒的位宽仅有4bit、8bit或16bit，个别也有32bit的。因此，必须把多个颗粒并联起来，组成一个位宽为64bit的数据集合，才可以和CPU互连。生产商把64bit集合称为一个物理BANK（Physical BANK），简写为P-BANK。为了和逻辑BANK相区分，也经常把P-BANK称为RANK或Physical RANK,把L-BANK则简称为BANK。
如果每个内存颗粒的位宽是8bit，应该由8个颗粒并联起来，组成一个RANK（64bit）；同理，如果颗粒的位宽是16bit，应该由4个颗粒组成一个RANK。
由此可知：Rank其实就是一组内存颗粒位宽的集合。具体说，当颗粒位宽×颗粒数=64bits时，这个模组就是有一个RANK。
为了保证和CPU的沟通，一个模组至少要有一个RANK。但是，为了保证有一定的内存容量，目前，DDR2内存，经常是采用一个模组两个RANK的架构。（过去也有用几个模组组成一个RANK的情况）。

“模组构成”中的“R”是“RANK”的意思。“2R”是说组成模组的RANK数（Number of ranks of memory installed）是2个。有“1R”和“2R”两种；
“模组构成”中的“×8”是颗粒的位宽(bit width)，有×4、×8和×16三种
2.如何根据模组的编号计算模组的RANK数？
答：根据模组组成原理可以知道：如果模组的深度等于颗粒的深度，就是一个RANK；如果模组的深度等于两倍颗粒深度，就是两个RANK。例如，编号为M378B5673DZ1的三星模组的模组深度是256M。又因为这种模组采用的是K4T1G084QD颗粒。这种颗粒的密度是1024Mb；位宽是8b，因此，颗粒深度是1024Mb÷8b=128M。即模组深度是颗粒深度的两倍，因此，是两个RANK。
此外，从模组编号或颗粒编号给出的颗粒位宽和实际颗理粒数也可以计算出RANK数。例如，当颗粒位宽是8b时，模组用了8个颗粒，8×8b=64b，就是一个RANK；如果用了16颗颗粒，16×8b=128b，就是两个RANK。
3.模组的RANK数跟模组的面数有什么关系？
答：模组的面（side）数跟RANK数是两个不同的概念。而且在内存的编号中也都没有反映面数。但是，模组的面，不是一个，就是两个；而目前的RANK数也是这样。因此，用符号表示它们时，很容易混淆。但是，可以很明确地说：内存标签中的“R”是表示RANK,不是表示面数，内存“面”的英文字是Side，如果表示两个面的话面，应该是“2S”才是呀！
4.内存标签上的2R×8就表明内存是双面8个颗粒吗？
答：不是的。“R”表示RANK，这在上面已经解释过了。“×8”就是颗粒位宽是8bit的意思。因为1个RANK是64bit，两个RANK就是128bit，因此，符号“2R×8”就表示这个模组有2个RANK,颗粒的位宽是8b。因此，这个模组用的颗粒是128b÷8b/颗=16颗，而不是8颗。同理，当内存条上的标签标明是“1R×16”时，就表明这个模组是1个RANK；颗粒位宽是16bit。其颗粒数是64b÷16b/颗=4颗。绝不是16颗。
